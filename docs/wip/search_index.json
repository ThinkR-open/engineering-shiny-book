[
["index.html", "Building Big Shiny Apps - A Workflow Introduction Motivation Book structure About the authors Want to help? Other resources Acknowledgments", " Building Big Shiny Apps - A Workflow Colin Fay, Vincent Guyader, Cervan Girard, S√©bastien Rochette 2019-09-12 Introduction This book is still at a Work in Progress stage. Motivation This book will not get you started with Shiny, nor talk about how to deploy into production and scale your app. What we‚Äôll see is the process of building the app. Why? Lots of blog posts and books talk about starting to use shiny or putting apps in production. Very few (if any) talk about this grey area between getting started and pushing into production. So this is what this book is going to talk about: building Shiny application. We‚Äôll focus on the process, the workflow, and the tools we use at ThinkR when building big Shiny Apps. Hence, if you‚Äôre starting to read this book, we assume you have a working knowledge of how to build a small application, and want to know how to go one step further. Book structure Part 1 (Building big Shiny Apps) gives a general context about what is a successful Shiny Apps and what challenges arise when you‚Äôre dealing with a large scale application. It also introduces the {golem} package and more general concept about organising your workflow. This first part will be light on code: you‚Äôll read more about conceptual ideas and organisation strategy. Part 2 to 6 describes a series of steps you can take when you want to build a Shiny App, and the tooling associated with each step. Part 7 (Optimizing) tackles the question of optimization, first by presenting some common caveats of Shiny Apps, and then showing how to optimize R code, and use JavaScript to lighten R work. About the authors // TODO Want to help? Any feedbacks on the book is very welcome. Feel free to open an issue, or to make a PR if you spot a typo (I‚Äôm not a native english speaker, so there might be some waiting to be found ;) ). Other resources Getting started with Shiny Learn Shiny with RStudio Getting Started with Shiny (WIP) Mastering Shiny A gRadual intRoduction to Shiny Shiny into production Shiny in production: Principles, practices, and tools Shiny in Production Suggest a Resource! Acknowledgments // TODO : "],
["successfulshinyapp.html", "Chapter 1 About Successful Shiny Apps 1.1 A (very) short introduction to Shiny 1.2 What‚Äôs a complex Shiny App? 1.3 What‚Äôs a successful Shiny App?", " Chapter 1 About Successful Shiny Apps If you‚Äôre reading this page, chances are you already know what a Shiny App is ‚Äî a web application that communicates with R, built in R, and working with R. Almost anybody can create a prototype for a small data product in a matter of hours. And no knowledge of HTML, CSS or JavaScript is required, making it really easy to use ‚Äî you can rapidly create a POC. But what to do now you want to build a complex Shiny App? 1.1 A (very) short introduction to Shiny // TODO 1.2 What‚Äôs a complex Shiny App? // TODO 1.3 What‚Äôs a successful Shiny App? // TODO "],
["planning.html", "Chapter 2 Planning Ahead 2.1 Working with a ‚Äúlong-term‚Äù mindset 2.2 Working as a team: tools &amp; organisation", " Chapter 2 Planning Ahead 2.1 Working with a ‚Äúlong-term‚Äù mindset ‚ÄúRome ne fut pas faite toute en un jour‚Äù French proverb 2.1.1 Prepare for success -&gt; Planification is everything -&gt; Get ready for complexity -&gt; Think big, act small. Understand the big picture, but implement one small feature at a time. -&gt; Future is now 2.1.2 Applying the KISS principle The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. .right{ text-align: right;} KISS principle Deeply rooted in the Unix Philosophy, the KISS principle stands for ‚ÄúKeep Thing Simple, Stupid‚Äù. The story behind this principle is supposed to be that Kelly Johnson, lead engineer at the Lockheed Skunk Works, gives his workers a set of very common tools and said that the airplanes should be repairable with these tools, and these tools only. The idea behing that being that the action of repairing the aicrafts that come out of their factories should be repairable by the average engineer. -&gt; Help you reason about the app on the long run -&gt; Hard to remove a feature once it‚Äôs implemented 2.1.3 Think long-term maintnenance, now Maintainance, on the other hand, is something to think about from the beginning. It includes being able to ensure that the application will work in the long run, and that new features can be easily implemented. Working in the long run: separate the code with ‚Äúbusiness logic‚Äù (aka the data manipulation and the algorithm, that can work outside the context of the app) from the code building the application. That way, you can write regression tests for these functions to ensure they are stable. Implement new elements: as we are working with modules, it‚Äôs easy to insert new elements inside the global application. 2.2 Working as a team: tools &amp; organisation Big Shiny Apps usually mean that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application. So, how do we organize that? 2.2.1 From the tools point of view: Use version control (not sure I have to expand on that topic ;) ) Think of your shiny app as a tree, and divide it as much as possible into little pieces. Then, create one Shiny module by piece. This allows you to split the work, and also to have smaller files ‚Äî it‚Äôs easier to work on 20 files of 200 lines than on one big app.R file. 2.2.2 From the organisational point of view Define one person in charge of having the big picture of the app. This person will kick off the project, and write the skeleton of the app, with the good modules and files structure. This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. List the tasks, and open one issue for each task on your version control system. Each issue will be solved in a separate branch. Finally, assign one module to one developer ‚Äî if it seems that working on one module is a two-person job, divide again into two other submodules. This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. "],
["structure.html", "Chapter 3 Structuring your Project 3.1 Shiny App as a Package 3.2 Using Shiny Modules 3.3 Splitting your app into files", " Chapter 3 Structuring your Project 3.1 Shiny App as a Package In the next chapter you‚Äôll be introduced to the {golem} package, which is an opinionated framework for building production-ready Shiny Applications. This framework starts by creating a package skeleton waiting to be filled. But, in a world where Shiny Applications are mostly created as a series of files, why bother with a package? 3.1.1 What‚Äôs in a Shiny App? OK, so let‚Äôs ask the question the other way round. Think about your last Shiny which was created as a single-file (app.R) or two files app (ui.R and server.R). You‚Äôve got these two, and you put them into a folder. So, let‚Äôs have a review of what you‚Äôll need next for a robust application. First, metadata. In other words, the name of the app, the version number (which is crucial to any serious, production-level project), what the application does, who to contact if something goes wrong. Then, you need to find a way to handle the dependencies. Because you know, when you want to push your app into production, you can‚Äôt have this conversation with IT: IT: Hey, I tried to ‚Äòsource(‚Äúapp.R‚Äù)‚Äô but I‚Äôve got an error. R-dev: What‚Äôs the error? IT: It says ‚Äúcould not find package ‚Äòshiny‚Äô‚Äù. R-dev: Ah yes, you need to install {shiny}. Try to run ‚Äòinstall.packages(‚Äúshiny‚Äù)‚Äô. IT: Ok nice. What else? R-dev: Let me think, try also ‚Äòinstall.packages(‚ÄúDT‚Äù)‚Äô‚Ä¶ good? Now try ‚Äòinstall.packages(‚Äúggplot2‚Äù)‚Äô, and ‚Ä¶ [‚Ä¶] IT: Ok, now I source the ‚Äòapp.R‚Äô, right? R-dev: Sure! IT: Ok so it says ‚Äòcould not find function runApp()‚Äô R-dev: Ah, you‚Äôve got to do library(shiny) at the beginning of your script. And library(purrr), and library(jsonlite)*. * Which will lead to a Namespace conflict on the flatten() function that can cause you some debugging headache. So, hey, it would be cool if we could have a Shiny app that only imports specific functions from a package, right? So yes, dependencies matter. You need to handle them, and handle them correctly. Now, let‚Äôs say you‚Äôre building a big app. Something with thousands of lines of code. Handling a one-file or two-file shiny app with that much lines is just a nightmare. So, what to do? Let‚Äôs split everything into smaller files that we can call! And finally, we want our app to live long and prosper, which means we need to document it: each small pieces of code should have a piece of comment to explain what these specific lines do. The other thing we need for our application to be successful on the long term is tests, so that we are sure we‚Äôre not introducing any regression. Oh, and that would be nice if people can get a tar.gz and install it on their computer and have access to a local copy of the app! OK, so let‚Äôs sum up: we want to build an app. This app needs to have metadata and to handle dependencies correctly, which is what you get from the DESCRIPTION + NAMESPACE files of the package. Even more practical is the fact that you can do ‚Äúselective namespace extraction‚Äù inside a package, i.e you can say ‚ÄúI want this function from this package‚Äù. Also, this app needs to be split up in smaller .R files, which is the way a package is organized. And I don‚Äôt need to emphasize how documentation is a vital part of any package, so we solved this question too here. So is the testing toolkit. And of course, the ‚Äúinstall everywhere‚Äù wish comes to life when a Shiny App is in a package. 3.1.2 The other plus side of Shiny as a Package 3.1.2.1 Testing Nothing should go to production without being tested. Nothing. Testing production apps is a wide question, and I‚Äôll just stick to tests inside a Package here. Frameworks for package testing are robust and widely documented. So you don‚Äôt have to put any extra-effort here: just use a canonical testing framework like {testthat}. Learning how to use it is not the subject of this chapter, so feel free to refer to the documentation. See also Chapter 5 of ‚ÄúBuilding a package that lasts‚Äù. What should you test? First of all, as we‚Äôve said before, the app should be split between the UI part and the backend (or ‚Äòbusiness logic‚Äô) part. These backend functions are supposed to run without any interactive context, just as plain old functions. So for these ones, you can do classical tests. As they are backend functions (so specific to a project), {golem} can‚Äôt provide any helpers for that. For the UI part, remember that any UI function is designed to render an HTML element. So you can save a file as HTML, and then compare it to a UI object with the golem::expect_html_equal(). library(shiny) ui &lt;- tagList(h1(&quot;Hello world!&quot;)) htmltools::save_html(ui, &quot;ui.html&quot;) golem::expect_html_equal(ui, &quot;ui.html&quot;) # Changes ui &lt;- tagList(h2(&quot;Hello world!&quot;)) golem::expect_html_equal(ui, &quot;ui.html&quot;) This can for example be useful if you need to test a module. A UI module function returns an HTML tag list, so once your modules are set you can save them and use them inside tests. my_mod_ui &lt;- function(id){ ns &lt;- NS(&quot;id&quot;) tagList( selectInput(ns(&quot;this&quot;), &quot;that&quot;, choices = LETTERS[1:4]) ) } my_mod_ui_test &lt;- tempfile(fileext = &quot;html&quot;) htmltools::save_html(my_mod_ui(&quot;test&quot;), my_mod_ui_test) # Some time later, and of course saved in the test folder, # not as a temp file golem::expect_html_equal(my_mod_ui(&quot;test&quot;), my_mod_ui_test) {golem} also provides two functions, expect_shinytag() and expect_shinytaglist(), that test if an objet is of class &quot;shiny.tag&quot; or &quot;shiny.tag.list&quot;. Testing package launch: when launching golem::use_recommended_tests(), you‚Äôll find a test built on top of {processx} that allows to check if the application is launch-able. Here‚Äôs a short description of what happens: # Standard testthat things context(&quot;launch&quot;) library(processx) testthat::test_that( &quot;app launches&quot;,{ # We&#39;re creating a new process that runs the app x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, # As we are in the tests/testthat dir, we&#39;re moving # two steps back before launching the whole package # and we try to launch the app &quot;setwd(&#39;../../&#39;); pkgload::load_all();run_app()&quot; ) ) # We leave some time for the app to launch # Configure this according to your need Sys.sleep(5) # We check that the app is alive expect_true(x$is_alive()) # We kill it x$kill() } ) Note: this specific configuration will possibly fail on Continuous integration platform as Gitlab CI or Travis. A workaround is to, inside your CI yml, first install the package with remotes::install_local(), and then replace the setwd (...) run_app() command with myuberapp::run_app(). For example: in .gitlab-ci.yml: test: stage: test script: - echo &quot;Running tests&quot; - R -e &#39;remotes::install_local()&#39; - R -e &#39;devtools::check()&#39; in test-golem.R: testthat::test_that( &quot;app launches&quot;,{ x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, &quot;datuberapp::run_app()&quot; ) ) Sys.sleep(5) expect_true(x$is_alive()) x$kill() } ) 3.1.2.2 Documenting Documenting packages is a natural thing for any R developer. Any exported function should have its own documentation, hence you are ‚Äúforced‚Äù to document any user facing-function. Also, building a Shiny App as a package allows you to write standard R documentation: A README at the root of your package Vignettes that explain how to use your app A {pkgdown} that can be used as an external link for your application. 3.1.3 Deploy 3.1.3.1 Local deployment As your Shiny App is a standard package, it can be built as a tar.gz, sent to your colleagues, friends, and family, and even to the CRAN. It can also be installed in any R-package repository. Then, if you‚Äôve built your app with {golem}, you‚Äôll just have to do: library(myuberapp) run_app() to launch your app. 3.1.3.2 RStudio Connect &amp; Shiny Server Both these platforms expect a file app configuration, i.e an app.R file or ui.R / server.R files. So how can we integrate this ‚ÄúShiny App as Package‚Äù into Connect or Shiny Server? Using an internal package manager like RStudio Package Manager, where the package app is installed, and then you simply have to create an app.R with the small piece of code from the section just before. Uploading the package package folder to the server. In that scenario, you use the package folder as the app package, and upload the whole thing. Then, write an app.R that does: pkgload::load_all() shiny::shinyApp(ui = app_ui(), server = app_server) And of course, don‚Äôt forget to add this file in the .Rbuildignore! This is the file you‚Äôll get if your run golem::add_rconnect_file(). 3.1.3.3 Docker containers In order to dockerize your app, simply install the package as any other package, and use as a CMD R -e 'options(&quot;shiny.port&quot;=80,shiny.host=&quot;0.0.0.0&quot;);myuberapp::run_app()'. Of course changing the port to the one you need. You‚Äôll get the Dockerfile you need with golem::add_dockerfile(). 3.1.4 Resources R packages ‚ÄúBuilding a package that lasts‚Äù Writing R Extensions R package primer - a minimal tutorial 3.2 Using Shiny Modules // TODO 3.3 Splitting your app into files // TODO "],
["golem.html", "Chapter 4 Introduction to {golem} 4.1 Getting started with {golem} 4.2 Understanding {golem} package structure", " Chapter 4 Introduction to {golem} Ok, that‚Äôs a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it‚Äôs called {golem}. It can be found at https://github.com/ThinkR-open/golem The stable release can be found on CRAN, and installed with: install.packages(&quot;golem&quot;) {golem} can only be found on GitHub so you have to install it with: remotes::install_github(&quot;Thinkr-open/golem&quot;) {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. It all starts with an RStudio project, which contains a predefined setup for building your app. The idea is that with {golem}, you don‚Äôt have to focus on the foundation of your app, and can spend your time thinking about what you want to do, not about how to do it. It‚Äôs built on top of the working process we‚Äôve developed at ThinkR, and tries to gather in one place the functions and tools we‚Äôve created for building applications designed for production. 4.1 Getting started with {golem} Note before using {golem}: A {golem} app is contained inside a package, so knowing how to build a package is highly recommended. A {golem} app works better if you are working with shiny modules, so knowing how modules work is heavily recommended. In the rest of the book, we‚Äôll assume you‚Äôre working in RStudio. 4.2 Understanding {golem} package structure // TODO "],
["workflow.html", "Chapter 5 The workflow 5.1 Part 1: Design 5.2 Part 2: Prototype 5.3 Part 3: Build 5.4 Part 4: Secure 5.5 Part 5: Deploy", " Chapter 5 The workflow -&gt; Overview of the workflow 5.1 Part 1: Design // TODO 5.2 Part 2: Prototype // TODO 5.3 Part 3: Build // TODO 5.4 Part 4: Secure // TODO 5.5 Part 5: Deploy // TODO https://en.wikipedia.org/wiki/Principle_of_least_astonishment#cite_note-Raymond2004-1 https://www.ibm.com/developerworks/web/library/us-cranky10/index.html https://www.cs.tufts.edu/~nr/cs257/archive/mike-cowlishaw/rexx.pdf https://books.google.fr/books?id=I-NOcVMGWSUC&amp;pg=PA85&amp;redir_esc=y#v=onepage&amp;q&amp;f=false http://www.faqs.org/docs/artu/ch11s01.html http://canonical.org/~kragen/tao-of-programming.html#book4 "],
["uxmatters.html", "Chapter 6 UX Matters 6.1 The Unbearable Lightness of Being 6.2 The danger of over-featuring 6.3 About Accessibility 6.4 Further reading", " Chapter 6 UX Matters We have a natural tendency, as R-coders, to be focused on the back-end, i.e the server part of the application 1. Which is perfectly normal‚Äîchances are you didn‚Äôt come to R to code front-ends 2. But let‚Äôs state the truth: no matter how complex and innovative your backend is, your application is bad if your User Experience (UX) is bad. That‚Äôs the hard truth. If people can‚Äôt understand how to use your application, your application isn‚Äôt successful, no matter how incredible the backend is. This natural taste for back-end / server logic can deserve you on the long run: by neglecting the UI, you‚Äôll make your application less likely to be adopted among your users. Which is a good way to fail your application project. 6.1 The Unbearable Lightness of Being ‚ÄúSimplify, then add lightness‚Äù Colin Chapman CBE, Founder of Lotus Cars There are mainly two contexts where you‚Äôll be building a web app with R: one for professional use (i.e people will rely on this app to do their job), or for fun (i.e people will just use the app as a distraction). But in both cases, people will want the app to be useable, and easily usable. If people will use your app in a professional context, they don‚Äôt want to fight with your interface, read complexe manuals, or lose time understanding what is supposed to do what in your application. Think about all the professional applications and softwares that you‚Äôve been ranting about during your professional life. You don‚Äôt want your app to be one of that. On the other end, if users open your app for fun, they are not going to fight your app into submission: they are just going to give up using your app if it‚Äôs too complex to be used. 6.1.1 Make a self-explanatory app All kinds of things on a Web page can make us stop and think unnecessarily. Take names, for example. Typical culprits are cute or clever names, marketing-induced names, company-specific names, and unfamiliar technical names. .right{ text-align: right;} 'Don't make me think', Steve Krug -&gt; If things are clickable, it has to look clickable ‚ÄúAs a user, I should never have to devote a millisecond of thought to whether things are clickable‚Äîor not‚Äù .right{ text-align: right;} 'Don't make me think', Steve Krug -&gt; If there is a progression in your app, you should have a clear pattern of moving forward -&gt; If you need inputs, this should be made clear -&gt; Have some ‚Äúreading logic‚Äù: from left to right or right to left, there should be a progression in the way visual elements are organised. 6.1.2 ‚ÄúRule of Least Surprise‚Äù ‚ÄúRule of Least Surprise‚Äù or ‚ÄúPrinciple of Least Astonishment.‚Äù Rule of Least Surprise: In interface design, always do the least surprising thing. .right{ text-align: right;} 'Basic of the Unix Philosophy', Eric Steven Raymond Try to find a simple, and efficient UI. One that people can understand and use in a matter of seconds. Don‚Äôt implement features or visual elements that are not actually needed, just ‚Äúin case‚Äù. And spend time working on that UI, really thinking about what visual elements you are implementing. 6.2 The danger of over-featuring 6.2.1 Restrain reactivity As a designer, you think: they‚Äôll select this, and when they release the slider, this will update automatically. In real life, people make mistakes using the app, so if everything reacts to their every moves, the experience using the app can be bad. 6.2.2 Too much interactivity Don‚Äôt make things interactive if there is no value in adding interactivity. Adding interactivity widgets (in most cases) means adding visual elements to your original content: in other words, you‚Äôre adding visual components that might distract the user from focusing on the content of the information. Good rule: don‚Äôt add feature for the sake of adding a feature. Less is more. Example: using DT::data.table() or plotly or dygraph when it‚Äôs not needed. Maybe a parallel with 90/00 website design with a lot of visual noise vs minimalist modern design? 6.3 About Accessibility A user interface needs to be ‚Äúready to be consumed‚Äù by the broader audience possible. That means people with visual, mobility, or cognitive disabilities. Web Accessibility is pretty standard concept in the web development world, and you can learn about this straight from the first chapter of learn.freecodecamp.org. -&gt; Screen to speech technology : html semantic tags -&gt; Mobility impairment, people w/ parkinson for example. Exemple of the text input &amp; ENTER button. Making things keyboard friendly. -&gt; ColorBlind, viridis 6.4 Further reading ‚ÄòDon‚Äôt Make Me Think‚Äô, Steve Krug // TODO: Find resources about simplicity in UI/UX design aka what happens in the server side of a Shiny App‚Ü© Front-end are the visual parts of your application, the one with which your user interacts, as opposed to the back-end, which is what is installed on the server. In shiny, front-end is what correspond to the UI, back-end to the server.‚Ü© "],
["step-design.html", "Chapter 7 Don‚Äôt rush into coding 7.1 Designing before coding 7.2 Ask questions", " Chapter 7 Don‚Äôt rush into coding 7.1 Designing before coding Don‚Äôt rush into coding. I know you want to, because it‚Äôs what we like to do and what we are good at. But before entering the coding marathon, take time to think about the application and the way it will be deployed and used. 7.2 Ask questions Take a pen and a piece of paper and draw the app. Talk about it with the people who will use the app, just to decipher what they actually need. Take a moment to talk with the IT. Here are some questions you can ask: ‚ÄúWho are the end users of the app?‚Äù ‚Äî This will help you know if the end users are tech literate or not, and what they aim to achieve with the app. ‚ÄúHow frequently will they use the app?‚Äù ‚Äî The small details of the design &amp; the UI of an app you use on a daily basis is more crucial than when the app is used once a month. ‚ÄúWhat level of complexity and personalization do the users really need?‚Äù ‚Äî People writing app specifications sometimes want more functionalities than what is actually needed by the users. ‚ÄúWhat level of interactivity do you want, and to what extent is it central?‚Äù ‚Äî People love interactive graphs and like when things automatically sync with each other. Yet these two can make the app slower, without any significant gain. For example, being reactive to a selectInput() or a sliderInput() can lead to too much computation: maybe the user will not succeed to choose the right input the first, second or third time‚Ä¶ So let them do their choice, and add a button so that they can validate when they are ready. ‚ÄúHow important is it that the app is fast?‚Äù ‚Äî Should you spend a lot of time optimizing the little things? etc. Asking questions, taking notes, and drawing the app help you have a good idea of what is expected and what you have to do now. So, next step! "],
["stepprotopype.html", "Chapter 8 Building an ‚Äúipsum-app‚Äù 8.1 Prototyping is crucial 8.2 The ‚ÄúUI first‚Äù approach", " Chapter 8 Building an ‚Äúipsum-app‚Äù 8.1 Prototyping is crucial Rule of Optimization: Prototype before polishing. Get it working before you optimize it. http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#rule_of_optimization 8.2 The ‚ÄúUI first‚Äù approach I like to go ‚ÄúUI first‚Äù. For two main reasons: Once the UI is set, there is no ‚Äúsurprise implementation‚Äù. Once we agree on what elements there are in the app, there is no sudden ‚Äúoh the app needs to do that now‚Äù. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it‚Äôs much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we‚Äôve got a tool for you: it‚Äôs called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you‚Äôve got a draft of your app on a piece of paper, you can then move to the ‚Äúipsum-UI‚Äù stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. "],
["proto.html", "Chapter 9 Tools for prototyping 9.1 Fast prototyping with {shinipsum} 9.2 Using {fakir} for fake data generation", " Chapter 9 Tools for prototyping These two tools allow you to prototype a Shiny App and to go ‚ÄúUI first‚Äù. Learn more: 9.1 Fast prototyping with {shinipsum} // TODO https://github.com/ThinkR-open/shinipsum 9.2 Using {fakir} for fake data generation // TODO https://github.com/ThinkR-open/fakir "],
["stepbuild.html", "Chapter 10 Building app with {golem} 10.1 Using {golem} 10.2 dev/01_start.R 10.3 Day to Day Dev with {golem} 10.4 Launching the app 10.5 dev/02_dev.R 10.6 Adding these external resources to your app 10.7 Documentation 10.8 Using {golem} dev functions", " Chapter 10 Building app with {golem} Now the UI and the features are set, time to work on the backend. This part is pretty standard ‚Äî everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no ‚Äúsurprise implementation‚Äù, as the app has been well defined before. 10.1 Using {golem} 10.1.1 Create a package Once the package is installed, you can got to File &gt; New Project‚Ä¶ in RStudio, and choose ‚ÄúPackage for Shiny App Using golem‚Äù input. If you want to do it through command line, you can use: golem::create_shiny_template(path = &quot;path/to/package&quot;) This command allows you to create ‚Äúillegally-named‚Äù package (for example, 1234) by passing the check_name argument to FALSE. Note that this is not recommended and should only be done if you know what you are doing. Once you‚Äôve got that, a new RStudio project will be launched. Here is the structure of this project: DESCRIPTION ¬¶--dev/ ¬¶--01_start.R ¬¶--02_dev.R ¬¶--03_deploy.R ¬¶--run_dev.R ¬¶--inst/ ¬¶--app ¬¶--server.R ¬¶--ui.R ¬¶--www/ ¬¶--favicon.ico ¬¶--man/ ¬¶--run_app.Rd NAMESPACE myapp.Rproj ¬¶--R/ ¬¶--app_server.R ¬¶--app_ui.R ¬¶--run_app.R If you‚Äôre already familiar with R packages, most of these files will appear very familiar to you. That‚Äôs because a {golem} app IS a package. DESCRIPTION &amp; NAMESPACE: Package meta-data. dev/: Scripts that will be used along the process of developing your app. inst/app: You‚Äôll add external dependencies in www (images, css, etc). Don‚Äôt touch app_ui and app_server. man: Package doc, to be generated by R. myapp.Rproj: RStudio project. R/app_server.R, R/app_ui.R: Top level UI and server elements. R/run_app.R: a function to configure and launch the application. 10.2 dev/01_start.R Once you‚Äôve created your project, the first file that opens is dev/01_start.R. This file contains a series of commands to run once, at the start of the project. 10.2.1 Fill the DESC First, fill the DESCRIPTION by adding information about the package that will contain your app: golem::fill_desc( pkg_name = &quot;shinyexample&quot;, # The Name of the package containing the App pkg_title = , # The Title of the package containing the App pkg_description = , # The Description of the package containing the App author_first_name = , # Your First Name author_last_name = , # Your Last Name author_email = , # Your Email repo_url = NULL) # The (optional) URL of the GitHub Repo 10.2.2 Set common Files If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news usethis::use_mit_license(name = &quot;Your Name&quot;) # You can set another licence here usethis::use_readme_rmd() usethis::use_code_of_conduct() usethis::use_lifecycle_badge(&quot;Experimental&quot;) usethis::use_news_md() 10.2.3 Add a data-raw folder If you have data in your package usethis::use_data_raw() 10.2.4 Init Tests Create a template for tests: golem::use_recommended_tests() 10.2.5 Use Recommended Package This will add ‚Äúshiny‚Äù, ‚ÄúDT‚Äù, ‚Äúattempt‚Äù, ‚Äúglue‚Äù, ‚Äúhtmltools‚Äù, and ‚Äúgolem‚Äù as a dependecy to your package. golem::use_recommended_dep(&quot;&quot;) 10.2.6 Add various tools These two functions add a file with various functions that can be used along the process of building your app. See each file in details for a description of the functions. golem::use_utils_ui() golem::use_utils_server() 10.2.7 If you want to change the default favicon golem::use_favicon( path = &quot;path/to/favicon&quot;) You‚Äôre now set! You‚Äôve successfully initiated the project and can go to dev/02_dev.R. rstudioapi::navigateToFile(&quot;dev/02_dev.R&quot;) 10.3 Day to Day Dev with {golem} Now that you‚Äôre all set with your project init, time to move to development :) App development should happen through the dev/02_dev.R file, which contains common commands for developping. 10.4 Launching the app To run the app, go to the dev/run_dev.R file, and run the all thing. 10.5 dev/02_dev.R 10.5.1 Add modules The golem::add_module() functions creates a module in the R folder. The file and the modules will be named after the name parameter, by adding mod_ to the R file, and mod_*_ui and mod_*_server to the UI and server functions. golem::add_module(name = &quot;my_first_module&quot;) # Name of the module The new file will contain: # mod_UI mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns } ## To be copied in the UI # mod_my_first_module_ui(&quot;my_first_module_1&quot;) ## To be copied in the server # callModule(mod_my_first_module_server, &quot;my_first_module_1&quot;) In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 10.5.2 Add dependencies To be called each time you need a new package as a dependency: usethis::use_package(&quot;pkg&quot;) 10.5.3 Add tests Add more tests to your application: usethis::use_test(&quot;app&quot;) 10.5.4 Add a browser button Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/ golem::browser_button() 10.5.5 Add external files These functions create external dependencies (JavaScript and CSS). add_js_file() creates a simple JavaScript file, while add_js_handler() adds a file with a skeleton for shiny custom handlers. golem::add_js_file(&quot;script&quot;) golem::add_js_handler(&quot;script&quot;) golem::add_css_file(&quot;custom&quot;) 10.6 Adding these external resources to your app You can add any external resource (JS, css) into inst/app/www. Then, You‚Äôll need to point to these external resources in golem_add_external_resources(). For example, if you‚Äôve created a CSS file with golem::add_css_file(&quot;custom&quot;), you can add the file with: tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) Also, you can list here the use of other packages, for example useShinyalert() from the {shinyalert} package. Note: we‚Äôve chosen to leave it ‚Äúraw‚Äù, in the sense that there is a addResourcePath and a tags$head. If you‚Äôre comfortable with {htmltools}, you can build a htmltools::htmlDependency. 10.7 Documentation 10.7.1 Vignette usethis::use_vignette(&quot;shinyexample&quot;) devtools::build_vignettes() 10.7.2 Code coverage usethis::use_travis() usethis::use_appveyor() usethis::use_coverage() 10.8 Using {golem} dev functions There‚Äôs a series of tools to make your app behave differently whether it‚Äôs in dev or prod mode. Notably, the app_prod() and app_dev() function tests for options( &quot;golem.app.prod&quot;) (or return TRUE if this option doesn‚Äôt exist). Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with cat_dev(). options( &quot;golem.app.prod&quot; = TRUE) golem::cat_dev(&quot;hey\\n&quot;) options( &quot;golem.app.prod&quot; = FALSE) golem::cat_dev(&quot;hey\\n&quot;) ## hey You can then make any function being ‚Äúdev-dependant‚Äù with the make_dev() function: log_dev &lt;- golem::make_dev(log) log_dev(10) ## [1] 2.302585 options( &quot;golem.app.prod&quot; = TRUE) log_dev(10) "],
["step-secure.html", "Chapter 11 Build yourself a safe net 11.1 Testing your app 11.2 A reproducible environment", " Chapter 11 Build yourself a safe net Securing your app means two things: testing, and locking the application environment. 11.1 Testing your app So first, be sure to include tests all along the building process ‚Äî just like any other R code. As the app is contained in a package, you can use standard testing tools for testing the business logic of your app ‚Äî as said in the first part, it‚Äôs important to split the backend functions and algorithm from the user interface. That means that these backend functions can run outside of the application. And yes, if they can run outside of the app, they can be tested the standard way, using {testthat}. When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. One other tool I like to use is Katalon Studio. It‚Äôs not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It‚Äôs not that straightforward to use, but once you get a good grasp of how it works, it‚Äôs a very powerful tool. 11.2 A reproducible environment Secondly, secure your app means that it can be deployed again any time in the future ‚Äî in other words, you have to ensure you‚Äôve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app ‚Äî so, provide an environment that can prevent your app from breaking when a package gets updated. For that, there is, of course, Docker, R specific tools like {packrat} or {renv}, or deploying custom CRAN repositories or package manager. "],
["secure.html", "Chapter 12 Secure your work 12.1 Git 12.2 CI and testing", " Chapter 12 Secure your work 12.1 Git Friends don‚Äôt let friends work on a coding project without version control. // TO DO 12.2 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the ‚Äúbusiness logic‚Äù side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. // TO DO: more info about the tools + link to resources. "],
["stepdeploy.html", "Chapter 13 Send your app to production", " Chapter 13 Send your app to production Tools for deployment are not the subject of this blog post so I won‚Äôt talk about this in detail (remember, we are talking about building üòâ ), but our two tools of choice are Docker &amp; ShinyProxy, and RStudio Connect. // TODO: link to resources. "],
["deploy-golem.html", "Chapter 14 Deploy with {golem} 14.1 Local deployment 14.2 Deploying Apps with {golem} 14.3 RStudio Environments 14.4 Docker", " Chapter 14 Deploy with {golem} 14.1 Local deployment // TODO 14.2 Deploying Apps with {golem} The dev/03_deploy.R file contains function for deploying on various plateforms. 14.3 RStudio Environments // TODO 14.4 Docker // TODO "],
["when-optimize.html", "Chapter 15 The Need for Optimization 15.1 Build first, then optimize 15.2 Tools for profiling", " Chapter 15 The Need for Optimization 15.1 Build first, then optimize // TODO 15.2 Tools for profiling // TODO "],
["optim-caveat.html", "Chapter 16 Common Application Caveats 16.1 Reactivity anti-patterns 16.2 Reading data 16.3 R does too much", " Chapter 16 Common Application Caveats 16.1 Reactivity anti-patterns // TODO 16.2 Reading data // TODO 16.3 R does too much // TODO "],
["optimizing-shiny-code.html", "Chapter 17 Optimizing Shiny Code 17.1 Reading data 17.2 Caching elements 17.3 Keeping things simple", " Chapter 17 Optimizing Shiny Code 17.1 Reading data // TODO 17.2 Caching elements // TODO 17.3 Keeping things simple // TODO "],
["optimjs.html", "Chapter 18 Using JavaSript 18.1 Client-side Optimization 18.2 JavaScript &lt;-&gt; Shiny communication 18.3 Common JavaScript patterns for Shiny 18.4 About {golem} js functions", " Chapter 18 Using JavaSript 18.1 Client-side Optimization // TODO 18.2 JavaScript &lt;-&gt; Shiny communication // TODO 18.3 Common JavaScript patterns for Shiny // TODO 18.4 About {golem} js functions {golem} comes with a series of JavaScript functions that you can call from the server. These functions are added by default with golem::activate_js() in app_ui. Then they are called with golem::invoke_js(&quot;function&quot;, &quot;ui_element&quot;). This ui_element define the UI element to interact with. It can be a full jQuery selector, an id or a class. 18.4.1 golem::activate_js() showid &amp; hideid, showclass &amp; hideclass show and hide elements through their id or class. session$sendCustomMessage(&quot;showid&quot;, ns(&quot;plot&quot;)) showhref &amp; hidehref hide and show a link by trying to match the href content. session$sendCustomMessage(&quot;showhref&quot;, &quot;panel2&quot;) clickon click on the element. You have to use the full jQuery selector. show &amp; hide show and hide elements, using the full jQuery selector. 18.4.2 About jQuery selectors #plop: the element with the id plop .pouet: elements of class pouet &quot;button:contains('this')&quot;: buttons with a text containing 'this' Note that in html, tags contains attributes. For example: &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; contains href &amp; data-value. You can refer to these attributes with [] after the tag name. a[href = &quot;https://thinkr.fr&quot;]: link with href being https://thinkr.fr a[data-value=&quot;panel2&quot;]: link with data-value being &quot;panel2&quot; "]
]
