[
["index.html", "Building Big Shiny Apps - A Workflow Introduction Motivation Book structure About the authors Want to help? Other resources Acknowledgments", " Building Big Shiny Apps - A Workflow Colin Fay, Vincent Guyader, Cervan Girard, Sébastien Rochette 2019-10-28 Introduction This book is still at a Work in Progress stage. Motivation This book will not get you started with Shiny, nor talk about how to deploy into production and scale your app. What we’ll see is the process of building the app. Why? Lots of blog posts and books talk about starting to use shiny or putting apps in production. Very few (if any) talk about this grey area between getting started and pushing into production. So this is what this book is going to talk about: building Shiny application. We’ll focus on the process, the workflow, and the tools we use at ThinkR when building big Shiny Apps. Hence, if you’re starting to read this book, we assume you have a working knowledge of how to build a small application, and want to know how to go one step further. Book structure Part 1 (Building big Shiny Apps) gives a general context about what is a successful Shiny Apps and what challenges arise when you’re dealing with a large scale application. It also introduces the {golem} package and more general concept about organising your workflow. This first part will be light on code: you’ll read more about conceptual ideas and organisation strategy. Part 2 to 6 describes a series of steps you can take when you want to build a Shiny App, and the tooling associated with each step. Part 7 (Optimizing) tackles the question of optimization, first by presenting some common caveats of Shiny Apps, and then showing how to optimize R code, and use JavaScript to lighten R work. About the authors // TODO Colin Fay Vincent Guyader Cervan Girard Sébastien Rochette Want to help? Any feedbacks on the book is very welcome. Feel free to open an issue, or to make a PR if you spot a typo (I’m not a native english speaker, so there might be some waiting to be found ;) ). Other resources Getting started with Shiny Learn Shiny with RStudio Getting Started with Shiny (WIP) Mastering Shiny A gRadual intRoduction to Shiny Shiny into production Shiny in production: Principles, practices, and tools Shiny in Production Suggest a Resource! Acknowledgments // TODO : "],
["successfulshinyapp.html", "Chapter 1 About Successful Shiny Apps 1.1 A (very) short introduction to Shiny 1.2 What’s a complex Shiny App? 1.3 What’s a successful Shiny App?", " Chapter 1 About Successful Shiny Apps If you’re reading this page, chances are you already know what a Shiny App is — a web application that communicates with R, built in R, and working with R. The beauty of {shiny} is that it makes it easy for anybody to create a small app in a matter of hours. With small and simple Shiny apps, no knowledge of HTML, CSS or JavaScript is required, which makes it really easy to use — you can rapidly create a POC for a data-product and showcase an algorithm or present your results with an elegant, simple to build user interface. 1.1 A (very) short introduction to Shiny // TODO 1.2 What’s a complex Shiny App? Complex software is harder to think about, harder to test, harder to debug, and harder to maintain — and above all, harder to learn and use. .right{ text-align: right;} The Art of Unix Programming 1.2.1 Reaching the cliff of complexity Things are quite simple when it comes to small prototypes or proof of concepts. But things change when your application reaches “the cliff of complexity” 1. But what do we mean by complexity? Getting a clear definition is not an easy task 2 as it very depends on who is concerned and who you’re talking to. But let’s try to come with a definition that will serve us in the context of engineering Shiny applications. When building sofwares, we can think of complexity from two points of view: the complexity as it is seen by the coder, and the complexity as it is seen by the customer / end user 3. 1.2.1.1 Two views of complexity From the developer point of view An app is to be considered complex when it is big enough in term of size and functionalities so that it makes it impossible to reason about it at once, and you need to rely on tools to understand and handle this complexity. This type of complexity is called implementation complexity. One of the goal of this book is to present you a methodology and toolings that will help you reduce this form of complexity. For example, we’ll talk about a design / prototype / build / secure / deploy, which helps you reduce the complexity of implementing and maintain new app features. We’ll also be talking at length about the {golem} package, which provides a toolkit for reducing the cognitive load of handling complexity in large Shiny applications. For example, creatign a new Shiny module requires following a very strict structure. One way to do that is to remember how to do that and to code it from scratch (a method which has an important cognitive load and is very error prone). Another way is to copy and paste an existing module and to adapt it, which is, as any copy and paste, likely to lead to errors. Or there is the {golem} way, in which you rely on a robust tool to build the foundations for a new module. Another benefit of adopting automation for common application component is that it allows to be sure that you’re following a convention. And conventions are crucial when it comes to building and maintaining complex system: by imposing a formalized structure for a piece of code, it ehances readability, lessens the learning curve, and lightens the chance for typo and/or copy and paste error. Customers and users On the other hand, customers and end user see complexity as interface complexity. Interface complexity can be driven by a lot of elements, for example the probability of making an error while using the app, the difficulty to understand the logical progression in the the app, the presence of unfamiliar behaviour or terms, visual distractions… This book will also bring you strategy to help you cope with the need for simplification when it comes to designin interface. 1.2.1.2 Balancing complexities There is an inherent tension between these two source of complexity, as designing an app means finding a good balance between implementation ann interface complexity. Reducing implementation complexity means one has to make some decisions that will lower one while rising the other. For example, we can think of something very common in Shiny: the “too much reactivity” pattern. In some cases, coders try to make everything reactive: e.g., three sliders and a selectInput, all updating a plot. This behaviour lowers the interface complexity: users don’t have to think a lot about what they are doing, they just move things around and it updates. But this kind of pattern can make the app computing too much things: user rarely go to the slider value they need from the first shoot, and usually miss what they want to select in an input. So, way more computation for R. One solution can be to delay reactivity or to cache things so that R computes less things. But that comes with a cost: handling delayed reactivity and caching elements, which increases implementation complexity. One other solution is simply to add a button after the input, and only update the plot when the user clicks on it. This pattern makes it easier to control reactivity from an implementation side. But it can make the interface a little bit more complex for the user who have to perform another action. We’ll argue somewhere else in the book that on the other hand, not enough reactivity is better than too much reactivity, as the latter increases computation time, and relies on the assumption that the user makes the right action on the first try. Another good example is {shiny}’s dateRangeInput() function being able to take a start which is posterior to the end (which is the behaviour of the JavaScript plugin used in {shiny} to create this input). Handling this special case is doable: with a little bit of craft, you can watch what the user inputs and throw an error if the start is after the end 4. That solution augments the implementation complexity, while leaving it as is requires the user to think about wether or not the starting date is before the ending date, thus increasing the interface complexity. -&gt; Insert here something of the like: “It’s up to you to think about what’s the best balance between these two sources.” 1.2.1.3 Assessing complexity Another measure that sometime comes in the discussion is the codebase size. It’s relatively hard to use this number of lines metric, as R is very permissive when it comes to identation and line break. It also depends on your coding style and the packages you’re using. For example, tidyverse packages encourage the use of the pipe (%&gt;%) 5 with one function by line, producing more lines in the end code. Consider this piece of valid R code: iris[ 1 : 5, c ( &quot;Species&quot; ) ] [1] setosa setosa setosa setosa setosa Levels: setosa versicolor virginica 9 lines of code for something that should also be written in one, three, five… Another drawback of this metric is that it focuses on numbers instead of readability, and on the long run yes, readability matters 6. // TODO -&gt; https://github.com/hrbrmstr/cloc devtools::install_github(&quot;hrbrmstr/cloc&quot;) library(cloc) cloc_cran(&quot;shiny&quot;, .progress = FALSE) cloc_cran(&quot;attempt&quot;, .progress = FALSE) -&gt; Cyclomatic complexity https://en.wikipedia.org/wiki/Cyclomatic_complexity -&gt; https://github.com/MangoTheCat/cyclocomp 1.2.2 With great complexity come great responsibilities When your program reaches this state, there is a lot of potential for failure, be it from a developer perspective or from a user point of view. For the code, bugs are harder to anticipate: it’s hard to think about all the different paths the software can follow, it’s hard to detect bugs because they are deeply nested in the numerous routines the app is doing. It’s also hard to think about what the state of your app is at a given moment in time because of the numerous inputs and outputs your app contains. From the user perspective, the more complex an app, the more important the learning curve is. Which means that the user will have to invest time learning how the app works, and will be even more disappointed if ever they realise this time has been a waste. 1.2.3 Production Grade Software Engineering Complexity is still frowned upon by a lot of developers, notably because it has been seen as something to avoid according to the Unix philosophy. But there are dozens of reasons why an app can become complex: for example, the question your app is answering to is quite a complicated question which involves a lot of computation and routines, the app is rather ambitious and implements a lot of features, etc. So yes, there is a chance that if you’re reading this page, you’re working or are planning to work on a complex Shiny app. And this is not necessarily a bad thing. Shiny apps can definitely be used to implement a production-grade 7 software, but production-grade software implies production-grade software engineering. And your goal to make this project a success is be to prepared, to use tools that will reduce the complexity of your app, and ensure that your app has the quality to age well. In other words, production-grade Shiny apps require working with a software engineering mindset. Which is not always that easy a task in the R world. R comes from the land of the academics and is still used a lot as an “experimentation tool”, and in context where production quality is one of the least concerns. Many developers in the R world have learned R as a tool for making statistics, not as a tool for building software. Both these contexts are very different and require different mindsets, different skills and tools. With {shiny}, as we said before, it’s quite easy to prototype a simple app, without any “hardcore” software engineering skills. And when we’re happy with our little proof of concept, we’re tempted to add something new. And another. And another. And without any structured methodology, we’re almost certain that we’ll reach the cliff of complexity very soon, with a code base that is hardly (if ever) ready to be refactored to be sent to production. The good news is that building a complex app with R (or with any other language) is not an impossible task. But it requires planning, rigor, and correct tooling. This is what this book is about: how to organise your Shiny App project in a way that is time and code efficient, and how to get the correct tooling for making your application a success. 1.3 What’s a successful Shiny App? Another good news is that your application does not have to be complex to be successful. Even more, in a world where “less is more”, the more you can reduce your application complexity, the more you’ll be prepared for success. So what’s a successful Shiny app? Defining such a metric is not that easy a task, but we can extract some common patterns when it comes to applications that can be listed as successful. 1.3.1 It exists First of all, an app is successful if it was delivered. In other words, the developer team was able to move from specification to implementation to testing to delivering. This is a very engineering-oriented definition of success, but that’s a pragmatic one: an app that never reaches the state of usability is not a successful app, as something along the way has blocked the process of finishing the code. This implies a lot of things: but mostly it implies that the team was able to organise itself in an efficient way, so that they were able to work together in making the project a success. And anybody that has already worked on a code base as a team knows it’s not an easy task. 1.3.2 It’s accurate The app was delivered, and it answers the question it is supposed to answer, or serves the purpose it is supposed to serve. Delivering is not the only thing to keep in mind: you can deliver a working app but it doesn’t work in the way it is supposed to work. Just as before, accuracy means that between the moment the idea appears in someone’s mind and the moment the app is actually ready to be used, everybody was able to work together toward a common goal. 1.3.3 It’s usable The app was delivered, it answers the question it is supposed to answer, and it is friendly on the user. Unless you’re coding for the sake of the art, there will always be one or more end user(s). And if these person can’t use the app because it’s too hard to use, too hard to understand, because it’s too slow or there is no inherent logic in the way the user experience is designed, then it’s hard to tell the app is a success. 1.3.4 It’s immortal Of course that’s a little bit far fetched, but when designing the app, you should set the ground for robustness in time and aim at a (theoretical) immortality of the app. Planning for the future is a very important component of a successful Shiny App project. Once the app is out, it’s successful if it can exist in the long run, with all the hazards that implies: new package versions that potentially break the code base, implementation of new features in the global interface, changing key features of the UI or the back-end, and not to mention passing the code base along to someone who has not worked on the first version, and who is now in charge of working on version 2. And this, again, is hard to do without effective planning and efficient tooling. Well, and this new person might simply be you, a month from now. And &quot;You’ll be there in the future too, maintaining code you may have half forgotten under the press of more recent projects. When you design for the future, the sanity you save may be your own.8 We borrow this term from Charity Major, as heard in Test in Production with Charity Majors, CoRecursive↩ Ironic right?↩ from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ see shiny/issues/2043#issuecomment-525640738 for an example↩ “Pressure to keep the codebase size down by using extremely dense and complicated implementation techniques can cause a cascade of implementation complexity in the system, leading to an un-debuggable mess.”, from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ By production-grade, we mean a software that can be used in a context where people use it for doing their job, and where failures or bugs have real-life consequences↩ The Art of Unix Programming, Eric Steven Raymond↩ "],
["planning.html", "Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset 2.2 Working as a team: tools &amp; organisation", " Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset “Rome ne fut pas faite toute en un jour” French proverb 2.1.1 Prepare for success // TODO -&gt; Planning is everything -&gt; Get ready for complexity -&gt; Think big, act small. Understand the big picture, but implement one small feature at a time. -&gt; Future is now 2.1.2 Applying the KISS principle // TODO The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. .right{ text-align: right;} KISS principle Deeply rooted in the Unix Philosophy, the KISS principle stands for “Keep It Simple, Stupid”. The story behind this principle is supposed to be that Kelly Johnson, lead engineer at the Lockheed Skunk Works, gave his workers a set of very common tools and said that the airplanes should be repairable with these tools, and these tools only. The idea behind being, that the action of repairing the aircrafts that come out of their factories should be possible to carry out by the average engineer. KISS will: -&gt; Help you reason about the app in the long run, since it is -&gt; Hard to remove a feature once it’s implemented 2.1.3 Think long-term maintenance, now // TODO Maintenance, on the other hand, is something to think about from the beginning. It includes being able to ensure that the application will work in the long run, and that new features can be easily implemented. Working in the long run: separate the code containing the “business logic” (aka the data manipulation and the algorithms, which can work outside the context of the app) from the code building the application. That way, you can write regression tests for these functions to ensure they are stable. Implement new elements: as we are working with modules, it’s easy to insert new elements inside the global application. 2.2 Working as a team: tools &amp; organisation Big Shiny Apps usually mean that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application. So, how do we organize that? 2.2.1 From the tools point of view: // TODO Use version control (not sure I have to expand on that topic ;) ) Think of your shiny app as a tree, and divide it as much as possible into little pieces. Then, create one Shiny module piece by piece. This allows you to split the work, and also to have smaller files — it’s easier to work on 20 files of 200 lines than on one big app.R file. 2.2.2 From the organisational point of view // TODO Define one person to be in charge of having the big picture of the app. This person will kick off the project, and write the skeleton of the app, with a good module and files structure. This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. List the tasks, and open one issue for each task on your version control system. Each issue will be solved in a separate branch. Finally, assign one module to one developer — if it seems that working on one module is a two-person job, divide again into two other submodules. This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. "],
["structure.html", "Chapter 3 Structuring your Project 3.1 Shiny App as a Package 3.2 Using Shiny Modules 3.3 Splitting your app into files", " Chapter 3 Structuring your Project 3.1 Shiny App as a Package In the next chapter you’ll be introduced to the {golem} package, which is an opinionated framework for building production-ready Shiny Applications. This framework starts by creating a package skeleton waiting to be filled. But, in a world where Shiny Applications are mostly created as a series of files, why bother with a package? 3.1.1 What’s in a Shiny App? OK, so let’s ask the question the other way round. Think about your last Shiny which was created as a single-file (app.R) or two files app (ui.R and server.R). You’ve got these two, and you put them into a folder. So, let’s have a review of what you’ll need next for a robust application. First, metadata. In other words, the name of the app, the version number (which is crucial to any serious, production-level project), what the application does, who to contact if something goes wrong. Then, you need to find a way to handle the dependencies. Because you know, when you want to push your app into production, you can’t have this conversation with IT: IT: Hey, I tried to ‘source(“app.R”)’ but I’ve got an error. R-dev: What’s the error? IT: It says “could not find package ‘shiny’”. R-dev: Ah yes, you need to install {shiny}. Try to run ‘install.packages(“shiny”)’. IT: Ok nice. What else? R-dev: Let me think, try also ‘install.packages(“DT”)’… good? Now try ‘install.packages(“ggplot2”)’, and … […] IT: Ok, now I source the ‘app.R’, right? R-dev: Sure! IT: Ok so it says ‘could not find function runApp()’ R-dev: Ah, you’ve got to do library(shiny) at the beginning of your script. And library(purrr), and library(jsonlite)*. * Which will lead to a Namespace conflict on the flatten() function that can cause you some debugging headache. So, hey, it would be cool if we could have a Shiny app that only imports specific functions from a package, right? So yes, dependencies matter. You need to handle them, and handle them correctly. Now, let’s say you’re building a big app. Something with thousands of lines of code. Handling a one-file or two-file shiny app with that much lines is just a nightmare. So, what to do? Let’s split everything into smaller files that we can call! And finally, we want our app to live long and prosper, which means we need to document it: each small pieces of code should have a piece of comment to explain what these specific lines do. The other thing we need for our application to be successful on the long term is tests, so that we are sure we’re not introducing any regression. Oh, and that would be nice if people can get a tar.gz and install it on their computer and have access to a local copy of the app! OK, so let’s sum up: we want to build an app. This app needs to have metadata and to handle dependencies correctly, which is what you get from the DESCRIPTION + NAMESPACE files of the package. Even more practical is the fact that you can do “selective namespace extraction” inside a package, i.e you can say “I want this function from this package”. Also, this app needs to be split up in smaller .R files, which is the way a package is organized. And I don’t need to emphasize how documentation is a vital part of any package, so we solved this question too here. So is the testing toolkit. And of course, the “install everywhere” wish comes to life when a Shiny App is in a package. 3.1.2 The other plus side of Shiny as a Package 3.1.2.1 Testing Nothing should go to production without being tested. Nothing. Testing production apps is a wide question, and I’ll just stick to tests inside a Package here. Frameworks for package testing are robust and widely documented. So you don’t have to put any extra-effort here: just use a canonical testing framework like {testthat}. Learning how to use it is not the subject of this chapter, so feel free to refer to the documentation. See also Chapter 5 of “Building a package that lasts”. What should you test? First of all, as we’ve said before, the app should be split between the UI part and the backend (or ‘business logic’) part. These backend functions are supposed to run without any interactive context, just as plain old functions. So for these ones, you can do classical tests. As they are backend functions (so specific to a project), {golem} can’t provide any helpers for that. For the UI part, remember that any UI function is designed to render an HTML element. So you can save a file as HTML, and then compare it to a UI object with the golem::expect_html_equal(). library(shiny) ui &lt;- tagList(h1(&quot;Hello world!&quot;)) htmltools::save_html(ui, &quot;ui.html&quot;) golem::expect_html_equal(ui, &quot;ui.html&quot;) # Changes ui &lt;- tagList(h2(&quot;Hello world!&quot;)) golem::expect_html_equal(ui, &quot;ui.html&quot;) This can for example be useful if you need to test a module. A UI module function returns an HTML tag list, so once your modules are set you can save them and use them inside tests. my_mod_ui &lt;- function(id){ ns &lt;- NS(&quot;id&quot;) tagList( selectInput(ns(&quot;this&quot;), &quot;that&quot;, choices = LETTERS[1:4]) ) } my_mod_ui_test &lt;- tempfile(fileext = &quot;html&quot;) htmltools::save_html(my_mod_ui(&quot;test&quot;), my_mod_ui_test) # Some time later, and of course saved in the test folder, # not as a temp file golem::expect_html_equal(my_mod_ui(&quot;test&quot;), my_mod_ui_test) {golem} also provides two functions, expect_shinytag() and expect_shinytaglist(), that test if an object is of class &quot;shiny.tag&quot; or &quot;shiny.tag.list&quot;. Testing package launch: when launching golem::use_recommended_tests(), you’ll find a test built on top of {processx} that allows to check if the application is launch-able. Here’s a short description of what happens: # Standard testthat things context(&quot;launch&quot;) library(processx) testthat::test_that( &quot;app launches&quot;,{ # We&#39;re creating a new process that runs the app x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, # As we are in the tests/testthat dir, we&#39;re moving # two steps back before launching the whole package # and we try to launch the app &quot;setwd(&#39;../../&#39;); pkgload::load_all();run_app()&quot; ) ) # We leave some time for the app to launch # Configure this according to your need Sys.sleep(5) # We check that the app is alive expect_true(x$is_alive()) # We kill it x$kill() } ) Note: this specific configuration will possibly fail on Continuous integration platform as Gitlab CI or Travis. A workaround is to, inside your CI yml, first install the package with remotes::install_local(), and then replace the setwd (...) run_app() command with myuberapp::run_app(). For example: in .gitlab-ci.yml: test: stage: test script: - echo &quot;Running tests&quot; - R -e &#39;remotes::install_local()&#39; - R -e &#39;devtools::check()&#39; in test-golem.R: testthat::test_that( &quot;app launches&quot;,{ x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, &quot;datuberapp::run_app()&quot; ) ) Sys.sleep(5) expect_true(x$is_alive()) x$kill() } ) 3.1.2.2 Documenting Documenting packages is a natural thing for any R developer. Any exported function should have its own documentation, hence you are “forced” to document any user facing-function. Also, building a Shiny App as a package allows you to write standard R documentation: A README at the root of your package Vignettes that explain how to use your app A {pkgdown} that can be used as an external link for your application. 3.1.3 Deploy 3.1.3.1 Local deployment As your Shiny App is a standard package, it can be built as a tar.gz, sent to your colleagues, friends, and family, and even to the CRAN. It can also be installed in any R-package repository. Then, if you’ve built your app with {golem}, you’ll just have to do: library(myuberapp) run_app() to launch your app. 3.1.3.2 RStudio Connect &amp; Shiny Server Both these platforms expect a file app configuration, i.e an app.R file or ui.R / server.R files. So how can we integrate this “Shiny App as Package” into Connect or Shiny Server? Using an internal package manager like RStudio Package Manager, where the package app is installed, and then you simply have to create an app.R with the small piece of code from the section just before. Uploading the package folder to the server. In that scenario, you use the package folder as the app package, and upload the whole thing. Then, write an app.R that does: pkgload::load_all() shiny::shinyApp(ui = app_ui(), server = app_server) And of course, don’t forget to add this file in the .Rbuildignore! This is the file you’ll get if you run golem::add_rconnect_file(). 3.1.3.3 Docker containers In order to dockerize your app, simply install the package as any other package, and use as a CMD R -e 'options(&quot;shiny.port&quot;=80,shiny.host=&quot;0.0.0.0&quot;);myuberapp::run_app()'. Of course changing the port to the one you need. You’ll get the Dockerfile you need with golem::add_dockerfile(). 3.1.4 Resources R packages “Building a package that lasts” Writing R Extensions R package primer - a minimal tutorial 3.2 Using Shiny Modules // TODO 3.3 Splitting your app into files // TODO "],
["golem.html", "Chapter 4 Introduction to {golem} 4.1 Getting started with {golem} 4.2 Understanding {golem} package structure", " Chapter 4 Introduction to {golem} OK, that’s a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it’s called {golem}. 4.1 Getting started with {golem} // TODO It can be found at https://github.com/ThinkR-open/golem The stable release can be found on CRAN, and installed with: install.packages(&quot;golem&quot;) {golem} dev version can be found on GitHub and you’ll have to install it with: remotes::install_github(&quot;Thinkr-open/golem&quot;) {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. It all starts with an RStudio project, which contains a predefined setup for building your app. The idea is that with {golem}, you don’t have to focus on the foundation of your app, and can spend your time thinking about what you want to do, not about how to do it. It’s built on top of the working process we’ve developed at ThinkR, and tries to gather in one place the functions and tools we’ve created for building applications designed for production. Note before using {golem}: A {golem} app is contained inside a package, so knowing how to build a package is highly recommended. A {golem} app works better if you are working with shiny modules, so knowing how modules work is heavily recommended. In the rest of the book, we’ll assume you’re working in RStudio. 4.2 Understanding {golem} package structure When starting a new project with {golem} (here on an app called golex), you’ll start with this specific architecture. fs::dir_tree(&quot;golex&quot;) golex ├── DESCRIPTION ├── NAMESPACE ├── R │ ├── app_server.R │ ├── app_ui.R │ └── run_app.R ├── dev │ ├── 01_start.R │ ├── 02_dev.R │ ├── 03_deploy.R │ └── run_dev.R ├── inst │ └── app │ └── www │ ├── favicon.ico │ └── plop.js └── man └── run_app.Rd If you are familiar with packages, this structure will look familiar to you. And that’s for a good reason: an app built with {golem} IS a package. Let’s focus on these various elements for a moment in order to be sure you understand what part each file plays and how you can use (or not use) each of them. 4.2.1 DESCRIPTION &amp; NAMESPACE The DESCRIPTION and NAMESPACE are standard package files (i.e. they are not {golem}-specific). In the first, you’ll find a series of metadata about your package, for example who wrote the package, what’s the package version, what is its goal, who to complain to if things go wrong, and also information about external dependencies, the license, the encoding…. This DESCRIPTION file will be filled automatically by the first function you’ll run in dev/01_start.R, and by other functions from the dev/ scripts. In other words, most of the time you won’t interact with it directly, but through wrappers from {golem} and {usethis}. The NAMESPACE file is one of the most important file in your package. It’s also the one you’ll NEVER edit by end! R uses this one to define how to interact with the rest of the library: what function to import and from which package and what function to export, i.e what functions are available when you do library(golex). This file will be built when running the documenting process in your R package: {roxygen2} will scan all your .R files, and build the man/ + the NAMESPACE, by scanning the roxygen tags there. Explaining how these files are to be filled and how to document your functions is out of the scope of this book, as we hope if you’re reading this lines you’re already familiar with how to build a package. If you’d like to learn more about these, here are some resources you can refer to: Writing R Extensions - The DESCRIPTION file Writing R Extensions - Package namespaces R Packages - Package metadata R Packages - Namespace Building a package that lasts — eRum 2018 workshop 4.2.2 R/ The R/ folder is also the standard folder where you’ll be putting all your app functions. When you start your app project, this folder is pre-populated with three .R: app_server.R, app_ui.R, and run_app.R. During the process of building your application, all the core functionalities of your app will go there: you’ll put there the content of your modules (with golem::add_modules()) and the utilitarian / business logic functions you’ll build with golem::add_utils() and golem::add_fct(). If you want to add a standard file (that is to say out of {golem} nomenclature), you can call usethis::use_r(&quot;name&quot;), which create a R/name.R file. All your .R file should go there, with the only exception of the files you’ll create when deploying to RStudio products: these processes needing an app.R at the root of the project, the golem::add_rstudioconnect_file() will bypass this “.R only in R/” rule to add a file at your package root. Good news is that {golem} also knows that a package with an app.R at its root can’t build, so this file is added to the .Rbuildignore. If you’ve been building classic Shiny Apps, you’ve been use to source() your R files at the beginning of your app.R or ui.R/server.R. Keep in mind that, as we are building a package, we don’t need to source files from one place to another: {golem}, be it in the dev/run_dev.R, app.R for RStudio products, or running the run_app() function, leverages the package structure to allow you to have access to other functions from inside the whole R/ folder9. Note also that this folder can’t contain sub-folders. 4.2.2.1 app_server.R #&#39; @import shiny app_server &lt;- function(input, output,session) { # List the first level callModules here } This first function contains your server logic. If you’re familiar with the classic ‘ui.R / server.R’ methodology, this function can be thought of as a drop in replacement for the content of the function you’ve got in your server.R. Building a complex Shiny application commonly implies using Shiny modules. If so, you’ll be adding there a series of callModule(), the ones you’ll get on the very bottom of the file created with golem::add_module(). You’ll also find there global elements from your server-logic: top reactiveValues, connections to databases, options setting… 4.2.2.2 app_ui.R #&#39; @import shiny app_ui &lt;- function() { tagList( # Leave this function for adding external resources golem_add_external_resources(), # List the first level UI elements here fluidPage( h1(&quot;golex&quot;) ) ) } This piece of the app_ui.R is designed to received the counterpart of what you put in your server. Everything here is to be put after the # List the first level UI elements here line. Just as with their server counterparts, the UI side of these elements are the one from the bottom of the file you’re creating with golem::add_module(). By default, {golem} uses a fluidPage(), which is {shiny}’s most commonly used template. If ever you want to use navBarPage(), this is where you’ll define this: replace one with the other, and you’ll be good to go. You can also define any other template page, for example with an htmlTemplate(). Keep in mind that removing the fluidPage() here implies that there is no available CSS / JS template to be used anymore, and you’ll need to be adding your own there. #&#39; @import shiny golem_add_external_resources &lt;- function(){ addResourcePath( &#39;www&#39;, system.file(&#39;app/www&#39;, package = &#39;golex&#39;) ) tags$head( golem::activate_js(), golem::favicon() # Add here all the external resources # If you have a custom.css in the inst/app/www # Or for example, you can add shinyalert::useShinyalert() here #tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) ) } The second part of this file contains the golem_add_external_resources() function, which is used to add, well, external resources. You may have noticed that this function is to be found above in the file, in the app_ui() function. This function is used for linking to external files inside your applications: notably the files you’ll create with golem::add_css_file() and friends. In golem_add_external_resources(), you can also define custom resourcesPath. The first line (the one with addResourcePath()) is the one allowing the inst/app/www folder to mounted and be available at www with your app when you launch it. That’s why later on, when creating CSS or JS files, you’ll be asked to add there tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;). The other part of this function, starting with tags$head, creates a &lt;head&gt; tag for your application. This &lt;head&gt; tag is a pretty standard tag, which is used in HTML to define a series of metadata about your app. We encourage you to add any new external file (e.g pictures) in this inst/app/www folder, so that you can later use it in the UI with the common www prefix. An other common pattern would be: Adding images in inst/app/img Calling addResourcePath( 'img', system.file('app/img', package = 'golex') ) Adding elements to your UI with tags$img(src = &quot;img/name.png&quot;). 4.2.2.3 run_app.R #&#39; Run the Shiny Application #&#39; #&#39; @export #&#39; @importFrom shiny shinyApp #&#39; @importFrom golem with_golem_options run_app &lt;- function(...) { with_golem_options( app = shinyApp(ui = app_ui, server = app_server), golem_opts = list(...) ) } This run_app()function is the one that you’ll use to launch the app10. The body of this function is wrapped inside with_golem_options(), which allows you to pass arguments to the run_app() function, which will later be callable with golem::get_golem_options(). Some example of passing arguments include run_app(prod = FALSE) or something in the like of run_app(user = &quot;admin). 4.2.3 inst/app/www/ The inst/app/www/ folder contains all the files which are gonna be made available at application run time. Any web application has external files that allows it to run11. For example, {shiny} and its fluidPage() bundles a series of CSS and JavaScript files, notably the Boostrap library, or jQuery. These external files enhance your app: CSS for the design part, and JavaScript for the interactive part (more or less). On top of that, you can add your own files: your own design with CSS, or your own JavaScript content (as we’ll see in the last chapters of this book). In order to work, you have to include, somewhere in the UI, a link to these files. That’s what the links in the golem_add_external_resources() are made for: linking the external resources that you’ll build with the following functions. golem::add_css_file() golem::add_js_file() golem::add_js_handler() golem::use_favicon() Be aware that these files are available under the www/ at application run time, i.e. that the www/ folder is available by your browser, not by R when it runs / generate your application. In other words, you can use the www prefix in the HTML generated in your UI, which is read by your browser, not from the R/server side. If you want to link to a file that is read during application generation, you’ll need to do, for example, includeMarkdown( system.file(&quot;app/www/plop.md&quot;, package = &quot;golex&quot;) ). 4.2.4 man/ This man/ folder includes the package documentation. It’s a common folder that is automatically filled when you document your app: notably when running the dev/run_dev.R script and the document_and_reload() function. As with the NAMESPACE and DESCRIPTION, these two files are out of scope of this book (and to be honest, you’ll probably never have to interact with them directly). To know more about documentation and how to build it, here are some external links: R Packages - Object documentation Building a package that lasts — eRum 2018 workshop Same goes for the dependencies: you’ll never have to call library() in an app built with {golem}.↩ Very technically speaking, it’s the print() from the object outputted by run_app() that launches the app, but that’s another story. ↩ Some webpages don’t need any external sources, as they don’t have any design and are plain HTML, but generally speaking we won’t call this format a web app. ↩ "],
["workflow.html", "Chapter 5 The workflow 5.1 Part 1: Design 5.2 Part 2: Prototype 5.3 Part 3: Build 5.4 Part 4: Secure 5.5 Part 5: Deploy", " Chapter 5 The workflow This book divides the workflow of building big Shiny apps in five parts: Design, Prototype, Build, Secure and Deploy. 5.1 Part 1: Design To Design is to participate to the conception of the application. This part comes before any line of code. As for any software or web application, there will be discussions between the end-users, the bakers and the developpers. In this part, we will propose some tools to help define the goal of the application and find a compromise between users’ dreams, technical issues and time allocated to the development. 5.2 Part 2: Prototype To Prototype is to define a visual proposition for the application. A Shiny application is a visual interface to communicate with end users. The general appearance, position of the different inputs and outputs as well as graphical interactions need to be chosen with care. In this part, we will propose the ‘UI-first’ method with tools to focus on the bodyshell of the app before engineering the engine. 5.3 Part 3: Build To Build is to develop the engine of the application. Bulding a robust Shiny application requires to use the correct development tools. In this part, we will propose to develop using {golem}, a package especially created to help design a robust and maintainable Shiny application inside a R package. 5.4 Part 4: Secure To Secure is to ensure your application will long last. Some good practices will help during the development of the application. In this part, we will go through unit tests, reproducible development environment, version control and continuous integration applied to Shiny applications. 5.5 Part 5: Deploy To Deploy is to put your application in production. There are multiple ways to present your application to its targeted public. In this part, we will quickly present methods to deploy your application and show how {golem} can help you in this task. "],
["uxmatters.html", "Chapter 6 UX Matters 6.1 The Unbearable Lightness of Being 6.2 The danger of over-featuring 6.3 About Accessibility 6.4 Further reading", " Chapter 6 UX Matters We have a natural tendency, as R-coders, to be focused on the back-end, i.e the server part of the application 12. Which is perfectly normal—chances are you didn’t come to R to code front-ends 13. But let’s state the truth: no matter how complex and innovative your backend is, your application is bad if your User Experience (UX) is bad. That’s the hard truth. If people can’t understand how to use your application, your application isn’t successful, no matter how incredible the backend is. This natural taste for back-end / server logic can deserve you on the long run: by neglecting the UI, you’ll make your application less likely to be adopted among your users. Which is a good way to fail your application project. 6.1 The Unbearable Lightness of Being // TODO “Simplify, then add lightness” Colin Chapman CBE, Founder of Lotus Cars There are mainly two contexts where you’ll be building a web app with R: one for professional use (i.e people will rely on this app to do their job), or for fun (i.e people will just use the app as a distraction). But in both cases, people will want the app to be useable, and easily usable. If people will use your app in a professional context, they don’t want to fight with your interface, read complexe manuals, or lose time understanding what is supposed to do what in your application. Think about all the professional applications and softwares that you’ve been ranting about during your professional life. You don’t want your app to be one of that. On the other end, if users open your app for fun, they are not going to fight your app into submission: they are just going to give up using your app if it’s too complex to be used. 6.1.1 Make a self-explanatory app All kinds of things on a Web page can make us stop and think unnecessarily. Take names, for example. Typical culprits are cute or clever names, marketing-induced names, company-specific names, and unfamiliar technical names. .right{ text-align: right;} 'Don't make me think', Steve Krug -&gt; If things are clickable, it has to look clickable “As a user, I should never have to devote a millisecond of thought to whether things are clickable—or not” .right{ text-align: right;} 'Don't make me think', Steve Krug -&gt; If there is a progression in your app, you should have a clear pattern of moving forward -&gt; If you need inputs, this should be made clear -&gt; Have some “reading logic”: from left to right or right to left, there should be a progression in the way visual elements are organised. 6.1.2 “Rule of Least Surprise” “Rule of Least Surprise” or “Principle of Least Astonishment.” Rule of Least Surprise: In interface design, always do the least surprising thing. .right{ text-align: right;} 'Basic of the Unix Philosophy', Eric Steven Raymond Try to find a simple, and efficient UI. One that people can understand and use in a matter of seconds. Don’t implement features or visual elements that are not actually needed, just “in case”. And spend time working on that UI, really thinking about what visual elements you are implementing. 6.2 The danger of over-featuring 6.2.1 Restrain reactivity // TODO As a designer, you think: they’ll select this, and when they release the slider, this will update automatically. In real life, people make mistakes using the app, so if everything reacts to their every moves, the experience using the app can be bad. 6.2.2 Too much interactivity // TODO Don’t make things interactive if there is no value in adding interactivity. Adding interactivity widgets (in most cases) means adding visual elements to your original content: in other words, you’re adding visual components that might distract the user from focusing on the content of the information. Good rule: don’t add feature for the sake of adding a feature. Less is more. Example: using DT::data.table() or plotly or dygraph when it’s not needed. Maybe a parallel with 90/00 website design with a lot of visual noise vs minimalist modern design? 6.3 About Accessibility // TODO A user interface needs to be “ready to be consumed” by the broader audience possible. That means people with visual, mobility, or cognitive disabilities. Web Accessibility is pretty standard concept in the web development world, and you can learn about this straight from the first chapter of learn.freecodecamp.org. -&gt; Screen to speech technology : html semantic tags -&gt; Mobility impairment, people w/ parkinson for example. Exemple of the text input &amp; ENTER button. Making things keyboard friendly. -&gt; ColorBlind, viridis 6.4 Further reading // TODO ‘Don’t Make Me Think’, Steve Krug aka what happens in the server side of a Shiny App↩ Front-end are the visual parts of your application, the one with which your user interacts, as opposed to the back-end, which is what is installed on the server. In shiny, front-end is what correspond to the UI, back-end to the server.↩ "],
["step-design.html", "Chapter 7 Don’t rush into coding 7.1 Designing before coding 7.2 Ask questions", " Chapter 7 Don’t rush into coding 7.1 Designing before coding // TODO Don’t rush into coding. I know you want to, because it’s what we like to do and what we are good at. But before entering the coding marathon, take time to think about the application and the way it will be deployed and used. 7.2 Ask questions // TODO Take a pen and a piece of paper and draw the app. Talk about it with the people who will use the app, just to decipher what they actually need. Take a moment to talk with the IT. Here are some questions you can ask: “Who are the end users of the app?” — This will help you know if the end users are tech literate or not, and what they aim to achieve with the app. “How frequently will they use the app?” — The small details of the design &amp; the UI of an app you use on a daily basis is more crucial than when the app is used once a month. “What level of complexity and personalization do the users really need?” — People writing app specifications sometimes want more functionalities than what is actually needed by the users. “What level of interactivity do you want, and to what extent is it central?” — People love interactive graphs and like when things automatically sync with each other. Yet these two can make the app slower, without any significant gain. For example, being reactive to a selectInput() or a sliderInput() can lead to too much computation: maybe the user will not succeed to choose the right input the first, second or third time… So let them do their choice, and add a button so that they can validate when they are ready. “How important is it that the app is fast?” — Should you spend a lot of time optimizing the little things? etc. Asking questions, taking notes, and drawing the app help you have a good idea of what is expected and what you have to do now. So, next step! "],
["stepprotopype.html", "Chapter 8 Building an “ipsum-app” 8.1 Prototyping is crucial 8.2 The “UI first” approach", " Chapter 8 Building an “ipsum-app” 8.1 Prototyping is crucial // TODO Rule of Optimization: Prototype before polishing. Get it working before you optimize it. http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#rule_of_optimization 8.2 The “UI first” approach // TODO I like to go “UI first”. For two main reasons: Once the UI is set, there is no “surprise implementation”. Once we agree on what elements there are in the app, there is no sudden “oh the app needs to do that now”. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it’s much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we’ve got a tool for you: it’s called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you’ve got a draft of your app on a piece of paper, you can then move to the “ipsum-UI” stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. "],
["rmdfirst.html", "Chapter 9 Building with RMarkdown", " Chapter 9 Building with RMarkdown // TODO "],
["proto.html", "Chapter 10 Tools for prototyping 10.1 Fast prototyping with {shinipsum} 10.2 Using {fakir} for fake data generation", " Chapter 10 Tools for prototyping Building the User Interface first should require the least possible calculations from the server part of your application. You focus on the appearance. The UI is usually a collection of buttons, figures and tables. Some being triggered by others. When first building your interface, you may only want to focus on where you place the different boxes and graphs. You will use the different *Input from {shiny} for inputs that will later affect the server part. You will also set the place for *Output, but these outputs will be empty. To show a first overview of what will look like your interface, you can use fake data and figures to fill the blank outputs. This is where {shinipsum} and {fakir} come to help. 10.1 Fast prototyping with {shinipsum} The goal of {shinipsum} is to provide random shiny elements to simulate interface outputs. Use lorem, the long “Lorem Ipsum” text to fill in text parts. Use the random_* functions in the server part of your application in combination with the appropriate render*(). This will fill the corresponding call to *Output() in the UI. For instance: random_DT() renders a DT::datatable() output with one of existing R internal datasets. random_ggplot(type = &quot;point&quot;) renders a random {ggplot2} graph with the selected type (corresponding to geom() in {ggplot2}). random_text(nwords = 10) renders a text with the defined number of words. library(shiny) library(shinipsum) library(DT) ui &lt;- fluidPage( h2(&quot;A Random DT&quot;), DTOutput(&quot;data_table&quot;), h2(&quot;A Random Plot&quot;), plotOutput(&quot;plot&quot;), h2(&quot;A Random Text&quot;), tableOutput(&quot;text&quot;) ) server &lt;- function(input, output, session) { output$data_table &lt;- DT::renderDT({ random_DT(5, 5) }) output$plot &lt;- renderPlot({ random_ggplot() }) output$text &lt;- renderText({ random_text(nwords = 50) }) } shinyApp(ui, server) Find out more in the corresponding website: https://thinkr-open.github.io/shinipsum/ 10.2 Using {fakir} for fake data generation {fakir} was primarily created to provide fake datasets for R tutorials and exercises. “Fake support ticket dataset” is built using fake_ticket_client() and “Fake questionnaire on mean of transport / goal dataset” is built using fake_sondage_answers(). They contain dates, numeric and character variables, with missing values allowing multiple exercises on data cleaning and graph building. They can also be joined with the included {sf} geographical dataset fra_sf allowing for maps creation. Fake datasets created with {fakir} can be used to build light examples on the use of the inputs, for filters or interactive maps for instance. When building your application inside a R package, as recommended in this book using {golem}, you may want to build small reproducible examples of your functions, to be presented in the vignettes and tested in the unit tests, prior to building the Shiny Apps itself. You can create these examples using {fakir}. Find out more in the corresponding website: https://thinkr-open.github.io/fakir/ "],
["stepbuild.html", "Chapter 11 Building app with {golem} 11.1 Using {golem} 11.2 dev/01_start.R 11.3 Day to Day Dev with {golem} 11.4 Launching the app 11.5 dev/02_dev.R 11.6 Adding these external resources to your app 11.7 Documentation 11.8 Using {golem} dev functions", " Chapter 11 Building app with {golem} Now the UI and the features are set, time to work on the backend. This part is pretty standard — everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no “surprise implementation”, as the app has been well defined before. 11.1 Using {golem} 11.1.1 Create a package Once the package is installed, you can got to File &gt; New Project… in RStudio, and choose “Package for Shiny App Using golem” input. If you want to do it through command line, you can use: golem::create_shiny_template(path = &quot;path/to/package&quot;) This command allows you to create “illegally-named” package (for example, 1234) by passing the check_name argument to FALSE. Note that this is not recommended and should only be done if you know what you are doing. Once you’ve got that, a new RStudio project will be launched. Here is the structure of this project: DESCRIPTION ¦--dev/ ¦--01_start.R ¦--02_dev.R ¦--03_deploy.R ¦--run_dev.R ¦--inst/ ¦--app ¦--server.R ¦--ui.R ¦--www/ ¦--favicon.ico ¦--man/ ¦--run_app.Rd NAMESPACE myapp.Rproj ¦--R/ ¦--app_server.R ¦--app_ui.R ¦--run_app.R If you’re already familiar with R packages, most of these files will appear very familiar to you. That’s because a {golem} app IS a package. DESCRIPTION &amp; NAMESPACE: Package meta-data. dev/: Scripts that will be used along the process of developing your app. inst/app: You’ll add external dependencies in www (images, css, etc). Don’t touch app_ui and app_server. man: Package doc, to be generated by R. myapp.Rproj: RStudio project. R/app_server.R, R/app_ui.R: Top level UI and server elements. R/run_app.R: a function to configure and launch the application. 11.2 dev/01_start.R Once you’ve created your project, the first file that opens is dev/01_start.R. This file contains a series of commands to run once, at the start of the project. 11.2.1 Fill the DESC First, fill the DESCRIPTION by adding information about the package that will contain your app: golem::fill_desc( pkg_name = &quot;shinyexample&quot;, # The Name of the package containing the App pkg_title = , # The Title of the package containing the App pkg_description = , # The Description of the package containing the App author_first_name = , # Your First Name author_last_name = , # Your Last Name author_email = , # Your Email repo_url = NULL) # The (optional) URL of the GitHub Repo 11.2.2 Set common Files If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news usethis::use_mit_license(name = &quot;Your Name&quot;) # You can set another licence here usethis::use_readme_rmd() usethis::use_code_of_conduct() usethis::use_lifecycle_badge(&quot;Experimental&quot;) usethis::use_news_md() 11.2.3 Add a data-raw folder If you have data in your package usethis::use_data_raw() 11.2.4 Init Tests Create a template for tests: golem::use_recommended_tests() 11.2.5 Use Recommended Package This will add “shiny”, “DT”, “attempt”, “glue”, “htmltools”, and “golem” as a dependecy to your package. golem::use_recommended_dep(&quot;&quot;) 11.2.6 Add various tools These two functions add a file with various functions that can be used along the process of building your app. See each file in details for a description of the functions. golem::use_utils_ui() golem::use_utils_server() 11.2.7 If you want to change the default favicon golem::use_favicon( path = &quot;path/to/favicon&quot;) You’re now set! You’ve successfully initiated the project and can go to dev/02_dev.R. rstudioapi::navigateToFile(&quot;dev/02_dev.R&quot;) 11.3 Day to Day Dev with {golem} Now that you’re all set with your project init, time to move to development :) App development should happen through the dev/02_dev.R file, which contains common commands for developping. 11.4 Launching the app To run the app, go to the dev/run_dev.R file, and run the all thing. 11.5 dev/02_dev.R 11.5.1 Add modules The golem::add_module() functions creates a module in the R folder. The file and the modules will be named after the name parameter, by adding mod_ to the R file, and mod_*_ui and mod_*_server to the UI and server functions. golem::add_module(name = &quot;my_first_module&quot;) # Name of the module The new file will contain: # mod_UI mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns } ## To be copied in the UI # mod_my_first_module_ui(&quot;my_first_module_1&quot;) ## To be copied in the server # callModule(mod_my_first_module_server, &quot;my_first_module_1&quot;) In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 11.5.2 Add dependencies To be called each time you need a new package as a dependency: usethis::use_package(&quot;pkg&quot;) 11.5.3 Add tests Add more tests to your application: usethis::use_test(&quot;app&quot;) 11.5.4 Add a browser button Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/ golem::browser_button() 11.5.5 Add external files These functions create external dependencies (JavaScript and CSS). add_js_file() creates a simple JavaScript file, while add_js_handler() adds a file with a skeleton for shiny custom handlers. golem::add_js_file(&quot;script&quot;) golem::add_js_handler(&quot;script&quot;) golem::add_css_file(&quot;custom&quot;) 11.6 Adding these external resources to your app You can add any external resource (JS, css) into inst/app/www. Then, You’ll need to point to these external resources in golem_add_external_resources(). For example, if you’ve created a CSS file with golem::add_css_file(&quot;custom&quot;), you can add the file with: tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) Also, you can list here the use of other packages, for example useShinyalert() from the {shinyalert} package. Note: we’ve chosen to leave it “raw”, in the sense that there is a addResourcePath and a tags$head. If you’re comfortable with {htmltools}, you can build a htmltools::htmlDependency. 11.7 Documentation 11.7.1 Vignette usethis::use_vignette(&quot;shinyexample&quot;) devtools::build_vignettes() 11.7.2 Code coverage usethis::use_travis() usethis::use_appveyor() usethis::use_coverage() 11.8 Using {golem} dev functions There’s a series of tools to make your app behave differently whether it’s in dev or prod mode. Notably, the app_prod() and app_dev() function tests for options( &quot;golem.app.prod&quot;) (or return TRUE if this option doesn’t exist). Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with cat_dev(). options( &quot;golem.app.prod&quot; = TRUE) golem::cat_dev(&quot;hey\\n&quot;) options( &quot;golem.app.prod&quot; = FALSE) golem::cat_dev(&quot;hey\\n&quot;) hey You can then make any function being “dev-dependant” with the make_dev() function: log_dev &lt;- golem::make_dev(log) log_dev(10) [1] 2.302585 options( &quot;golem.app.prod&quot; = TRUE) log_dev(10) "],
["step-secure.html", "Chapter 12 Build yourself a safe net 12.1 Testing your app 12.2 A reproducible environment", " Chapter 12 Build yourself a safe net Securing your app means two things: testing, and locking the application environment. 12.1 Testing your app // TODO So first, be sure to include tests all along the building process — just like any other R code. As the app is contained in a package, you can use standard testing tools for testing the business logic of your app — as said in the first part, it’s important to split the backend functions and algorithm from the user interface. That means that these backend functions can run outside of the application. And yes, if they can run outside of the app, they can be tested the standard way, using {testthat}. When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. One other tool I like to use is Katalon Studio. It’s not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It’s not that straightforward to use, but once you get a good grasp of how it works, it’s a very powerful tool. 12.2 A reproducible environment // TODO Secondly, secure your app means that it can be deployed again any time in the future — in other words, you have to ensure you’ve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app — so, provide an environment that can prevent your app from breaking when a package gets updated. For that, there is, of course, Docker, R specific tools like {packrat} or {renv}, or deploying custom CRAN repositories or package manager. "],
["secure.html", "Chapter 13 Secure your work 13.1 Git 13.2 CI and testing", " Chapter 13 Secure your work 13.1 Git Friends don’t let friends work on a coding project without version control. // TO DO 13.2 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the “business logic” side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. // TO DO: more info about the tools + link to resources. "],
["stepdeploy.html", "Chapter 14 Send your app to production", " Chapter 14 Send your app to production Tools for deployment are not the subject of this blog post so I won’t talk about this in detail (remember, we are talking about building 😉 ), but our two tools of choice are Docker &amp; ShinyProxy, and RStudio Connect. // TODO: link to resources. "],
["deploy-golem.html", "Chapter 15 Deploy with {golem} 15.1 Local deployment 15.2 Deploying Apps with {golem} 15.3 RStudio Environments 15.4 Docker", " Chapter 15 Deploy with {golem} 15.1 Local deployment // TODO 15.2 Deploying Apps with {golem} The dev/03_deploy.R file contains function for deploying on various plateforms. 15.3 RStudio Environments // TODO 15.4 Docker // TODO "],
["when-optimize.html", "Chapter 16 The Need for Optimization 16.1 Build first, then optimize 16.2 Tools for profiling", " Chapter 16 The Need for Optimization 16.1 Build first, then optimize // TODO 16.2 Tools for profiling // TODO "],
["optim-caveat.html", "Chapter 17 Common Application Caveats 17.1 Reactivity anti-patterns 17.2 Reading data 17.3 R does too much", " Chapter 17 Common Application Caveats 17.1 Reactivity anti-patterns // TODO 17.2 Reading data // TODO 17.3 R does too much // TODO "],
["optimizing-shiny-code.html", "Chapter 18 Optimizing Shiny Code 18.1 Reading data 18.2 Caching elements 18.3 Keeping things simple", " Chapter 18 Optimizing Shiny Code 18.1 Reading data // TODO 18.2 Caching elements // TODO 18.3 Keeping things simple // TODO "],
["optimjs.html", "Chapter 19 Using JavaScript 19.1 A quick introduction to JavaScript 19.2 Client-side JavaScript 19.3 JavaScript &lt;-&gt; Shiny communication 19.4 About {golem} js functions 19.5 Learn more about JavaScript", " Chapter 19 Using JavaScript In its core, building a Shiny app is building a JavaScript app that can talk with an R session. This process is invisible for most Shiny developers, who usually do everything with R. And in the end, it’s the case: most of the Shiny apps out there are written with R. But in fact, when you are writing UI elements in Shiny, what you are actually doing is building a series of HTML tags, which are then linked to JavaScript events. Later on, when the app is running, these JavaScript events will communicate with R, in the sense that they will send data to R, and receive data from R. Most of the time, when these JavaScript events are receiving data, they modify the page the user sees. What happens under the hood is a little bit complex and out of scope for this book, but the general idea is there: R talks to your browser through a web socket (that you can imagine as a small “phone line” with both softwares listening on one hand14), and this browser talks to R through the same web socket. // TODO: create here a simple Flowchart // R -&gt; (Web Socket) -&gt; JS // R &lt;- (Web Socket) &lt;- JS It’s important to note here that the communication happens in both ways: from R to JavaScript, and from JavaScript to R. In fact, when we write a piece of code like sliderInput(&quot;plop&quot;, &quot;this&quot;, 1, 10, 5), what we are doing is creating a binding between JavaScript and R, where JavaScript listens to any event happening in the browser on the slider with the id &quot;plop&quot;, and whenever JavaScript detects that something happens to this element, something (most of the time its value) is sent back to R. With output$bla &lt;- renderPlot({}), what we are doing is making the two communicates the other way around: we are telling JavaScript to listen to any incoming data from R for the id &quot;bla&quot;, and whenever JavaScript sees incoming data from R, it puts it into the proper HTML tag (here, JavaScript inserts in the page the image received from R). So even if everything is written with R, we are writing a web application, i.e. HTML, CSS and JavaScript elements. Once you’ve realized that, the possibilities are endless: in fact almost anything doable in a “classic” web app can be done in Shiny. What this also implies is that getting (even a little bit) better at writing HTML, CSS and especially JavaScript will make your app better, lighter, and more user friendly, as JavaScript is a language that has been designed to interact with a web page: change element appearances, hide and show things, click somewhere, show alerts and prompts… Knowing just enough JavaScript can improve the quality of your app: especially when you’ve been using R to build some complex UI renderings: think conditional panels, simulating a button click from the server, hide and show elements… All these things are good examples of where you should be using JavaScript instead of building more or less complex renderUI or insertUI patterns in your server. A good rule to live Moreover, the number of JavaScript libraries available on the web is tremendous ; and the good news is that Shiny has everything it needs to bundle external JavaScript libraries inside your application15. This is what this part of the book aims at: giving you just enough JavaScript knowledge to lighten your Shiny App, in order to improve the global user and developer experience. In this part, we’ll first see some JavaScript basics, which can be used “client-side” only, i.e. only in your browser, or by making R &amp; JS communicate with each other. In this part, we’ll also explore common patterns for JavaScript in Shiny. Finally, we’ll quickly present some of the functions from {golem} which are built on top of JavaScript. Note that this chapter is not supposed to be a comprehensive JavaScript course. External resources are linked all throughout this chapter and at the end if you want to dive deeper into JavaScript. 19.1 A quick introduction to JavaScript JavaScript is a programming language which has been designed to work in the browser16. There are three ways to include the JavaScript code inside your web app: As an external file, which is served to the browser alongside your main application page Inside a &lt;script&gt; HTML tag inside your page On a specific tag, for example by adding an onclick event straight on the tag Note that the good practice when it comes to include JavaScript is to add the code inside an external file. If you’re working with {golem}, including a JavaScript file is performed using two functions: golem::add_js_file(&quot;name&quot;), which adds a standard JavaScript file, i.e. one which is not meant to be used to communicate with R. We’ll see in the first part of this chapter how to add JavaScript code there. golem::add_js_handler(&quot;name&quot;), which creates a file with a skeleton for Shiny handlers. We’ll see this second type of elements in the JavaScript &lt;-&gt; Shiny communication part. OK, good, but what do we do now? 19.1.1 Understanding html, class, and id You have to think of a web page as a tree, where the top of the webpage is the root node, and every element in the page is a node in this tree (this tree is called a DOM, for Document Object Model). You can work on any of these HTML node with JavaScript: modify it, bind and/or listen to events, hide and show it… But first, you have to find a way to identify these elements: either as a group of elements or as a unique element inside the whole tree. That’s what html semantic elements, classes and ids are made for. Consider this piece of code: library(shiny) fluidPage( titlePanel(&quot;Hello Shiny&quot;), actionButton(&quot;go&quot;, &quot;go&quot;) ) &lt;div class=&quot;container-fluid&quot;&gt; &lt;h2&gt;Hello Shiny&lt;/h2&gt; &lt;button id=&quot;go&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;go&lt;/button&gt; &lt;/div&gt; This {shiny} code creates a piece of HTML code, which contains three nodes: a div with a specific class (a BootStrap container), an h2, which is a level two header, and a button which has an id and a class. Both are included into the div. Let’s detail what we’ve got here: HTML tags, which are the building blocks of the “tree”: here, div, h2 and button are HTML tags. The button has an id, which is short for “identifier”. This id has to to be unique: it’s this reference that allows to spot this exact element, and more specifically it’s this id that allows JavaScript and R to talk to each other: if you click on a button, you have to be sure that it’s this specific button, and only that one. Elements can have a class, which can apply to multiple elements. This can be used in JavaScript, but it’s also very useful for styling elements in CSS. 19.1.2 About jQuery &amp; jQuery selectors The jQuery framework is natively included in Shiny. jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. .right{ text-align: right;} jQuery home page jQuery is a very popular JavaScript library which is designed to manipulate the DOM, its events and its elements. It can be used to do a lot of things, like hide and show, change class, click somewhere… And to be able to do that, it comes with the notion of selectors, which will be put between $(). You can use, for example: $(&quot;#plop&quot;) to refer to the element with the id plop $(&quot;.pouet&quot;) to refer to element(s) of class pouet $(&quot;button:contains('this')&quot;) to refer to the buttons with a text containing 'this' You can also use special HTML attributes, which are specific to a tag. For example, the following HTML code: &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; contains the href &amp; data-value attributes. You can refer to these with [] after the tag name. $(&quot;a[href = 'https://thinkr.fr']) refers to link(s) with href being https://thinkr.fr $('a[data-value=&quot;panel2&quot;]') refers to link(s) with data-value being &quot;panel2&quot; All these selectors, along many others, are used to identify one or more node(s) in the big tree which is a web page. Once we’ve identified these elements, we can either extract or change data contained in these nodes, or launch methods contained inside these nodes. Indeed JavaScript, as R, can be used as a functional language, but most of what we do is done in an object-oriented way. In other words, you’ll interact with objects from the web page, and these objects contain data and methods. Note that this is not specific to jQuery: elements can also be selected with standard JavaScript. jQuery has the advantage of simplifying selections and actions, and to be cross-platform, making it easier to ship applications that can work on all major browsers. And, it comes with Shiny for free! 19.2 Client-side JavaScript It’s hard to give an exhaustive list of what you can do with JavaScript inside Shiny. As a Shiny app is part JavaScript, part R, once you’ve got a good grasp of JavaScript you can quickly enhance any of your applications. That being said, there are some common things that can be done that would allow you to immediately optimize your application: i.e. small JavaScript functions that will prevent you from writing complex algorithmic logic in your application server. 19.2.1 Common patterns $('#id').show(); and $('#id').hide(); show and hide one or more elements that match the given selector. For example, this can be use to replace: output$ui &lt;- renderUI({ if (this){ tags(...) } else { NULL } }) alert(&quot;message&quot;) uses the built-in alert-box mechanism from the user’s browser (i.e., the alert() function is not part of jQuery but it’s built inside the user’s browser). It works well as it relies on the browser instead of relying on R or on specific JavaScript library. You can use this functionality to replace a call to {shinyalert}: the result is a little bit less aesthetically pleasing, but that’s easier to implement and maintain. var x = prompt(&quot;this&quot;, &quot;that&quot;); this function open the built-in prompt, which is a text area where the user can input text. With this code, when the user clicks on “OK”, the text is stocked in a variable x, which you can then send back to R (see further part down this chapter for more info about how to do that). This can replace something like : mod &lt;- function() { modalDialog( tagList( textInput(ns(&quot;info&quot;), &quot;Your info here&quot;) ), footer = tagList( modalButton(&quot;Cancel&quot;), actionButton(ns(&quot;ok&quot;), &quot;OK&quot;) ) ) } observeEvent(input$show, { showModal(mod()) }) observeEvent(input$ok, { removeModal() }) $('#id').css('color', 'green'); changes the css attributes of the selected element(s). Here, we’re switching to green on the #id element. $(&quot;#id&quot;).text( &quot;this&quot; ); changes the text content to “this”. This can be used to replace output$ui &lt;- renderUI({ if (this){ tags$p(&quot;First&quot;) } else { tags$p(&quot;Second&quot;) } }) $(&quot;#id&quot;).remove(); completely removes the element from the DOM. IT can be used as a replacement for shiny::removeUI(), or as a conditional UI. 19.2.2 Where to put them - introduction to JavaScript events OK, now that we’ve got some ideas about JS code that can be used in Shiny, where do we put them? HTML and JS have a concept called events, which are… well events that happen when the user manipulates the webpage: when the user clicks, hovers (the mouse goes over an element), press the keyboard… All these events can be used to trigger a JavaScript function. Here are some example of adding JavaScript functions to DOM events: +onclick The onclick attribute can be add straight inside the HTML tag when possible: tags$button( &quot;Show&quot; onclick = &quot;$(&#39;#plot&#39;).show()&quot; ) Or with shiny::tagAppendAttributes: plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;hello world&#39;)&quot; ) Here is for example a small Shiny app that implements this behavior: library(shiny) library(magrittr) ui &lt;- function(request){ fluidPage( plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;iris plot!&#39;)&quot; ) ) } server &lt;- function(input, output, session){ output$plot &lt;- renderPlot({ plot(iris) }) } shinyApp(ui, server) You can find a real Life example of this tagAppendAttributes in the {tidytuesday201942} app: R/mod_dataviz.R#L109, where the click on the plot generates the creation of a Shiny input (we’ll see this below) That, of course, works well with very small JavaScript code. For longer JavaScript code, you can write a function inside and external file, and add it to your app. In {golem}, this works by launching the add_js_file(&quot;name&quot;), which will create a .js file. You’ll then need to add this function using the tags$script(src=&quot;www/name.js&quot;) inside the golem_add_external_resources() function in R/app_ui.R file. This, for example, could be: inst/app/www/script.js function alertme(id){ // Asking information var name = prompt(&quot;Who are you?&quot;); // Showing an alert alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } Then: plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alertme(&#39;plot&#39;)&quot; ) Inside this inst/app/www/script.js, you can also attach a new behavior with jQuery to one or several elements. For example, you can add this alertme / onclick behavior to all plots of the app: function alertme(id){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } /* We&#39;re adding this so that the function is launched only when the document is ready */ $(function(){ // Selecting all Shiny plots $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ alertme(this.id); }); }); Then, all the plots from your app will receive this on click event17. Note that there is a series of Shiny events, which are specific to Shiny but that you can used as the one we’ve just seen: function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); } $(function(){ // Waiting for Shiny to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); }); See JavaScript Events in Shiny for the full list of JavaScript events available in Shiny. 19.3 JavaScript &lt;-&gt; Shiny communication Now that we’ve seen some client-side optimization, i.e. R doesn’t do anything with these events when they happen (in fact R is not even aware that they happen), let’s now see how we can make these two communicate with each other. 19.3.1 From R to JavaScript Calling JS from the server side (i.e from R) is done by defining a series of CustomMessageHandler: these are functions with one argument that can then be called using the session$sendCustomMessage() method from the server. You can define them using this skeleton: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;fun&#39;, function(arg) { }) }); This skeleton is the one generated by golem::add_js_handler(&quot;plop&quot;). Then, it will be called from server-side with: session$sendCustomMessage(&quot;fun&quot;, list()) Note that the list() argument from your function will be converted to JSON, and read as such from JS. In other words, if your have an argument called x, and you call the function with list(a = 1, b = 12), then in JS you’ll be able to use x.a and x.b. For example: In inst/app/www/script.js Shiny.addCustomMessageHandler(&#39;computed&#39;, function(mess) { alert(&quot;Computed &quot; + mess.what + &quot; in &quot; + mess.sec + &quot; secs&quot;); }) Then in R: observe({ deb &lt;- Sys.time() # Do the computation for id Sys.sleep( sample(1:5, 1) ) session$sendCustomMessage( &quot;computed&quot;, list( what = &quot;plop&quot;, sec = round(Sys.time() - deb) ) ) }) 19.3.2 From JavaScript to R How to do the other way around (from JS to R)? Shiny apps, in the browser, contain an object called Shiny, which can be used to send values to R, by creating an IputValue. For example, with: Shiny.setInputValue(&quot;rand&quot;, Math.random()) you’ll bind an input that can be caught from the server side with: observeEvent( input$rand , { print( input$rand ) }) This Shiny.setInputValue can of course be used inside any JavaScript function. Here is a small example wrapping some of the things we’ve seen previously: In inst/app/www/script.js function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); Shiny.setInputValue(&quot;username&quot;, name) } $(function(){ // Waiting for Shiny to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ Shiny.setInputValue(&quot;last_plot_clicked&quot;, this.id); }); }); These events (getting the user name and the last plot clicked), can then be caught from the server side with: observeEvent( input$username , { cli::cat_rule(&quot;User name:&quot;) print(input$username) }) observeEvent( input$last_plot_clicked , { cli::cat_rule(&quot;Last plot clicked:&quot;) print(input$last_plot_clicked) }) Which will give: &gt; golex::run_app() Loading required package: shiny Listening on http://127.0.0.1:5495 ── User name: ───────────────────────────────────────────────────── [1] &quot;Colin&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plota&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plopb&quot; Important note: if you’re using modules, you’ll need to pass the namespacing of the id to be able to get it back from the server. This can be done using the session$ns function, which comes by default in any golem-generated module. And as an example speaks more than a 1000 words, here is what we mean by that: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;whoareyou&#39;, function(arg) { var name = prompt(&quot;Who are you?&quot;) Shiny.setInputValue(arg.id, name); }) }); mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton( ns(&quot;showname&quot;), &quot;Enter your name&quot; ) ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns observeEvent( input$showname , { session$sendCustomMessage( &quot;whoareyou&quot;, list( id = ns(&quot;name&quot;) ) ) }) observeEvent( input$name , { cli::cat_rule(&quot;Username is:&quot;) print(input$name) }) } 19.4 About {golem} js functions {golem} comes with a series of JavaScript functions that you can call from the server. These functions are added by default with golem::activate_js() in app_ui. Then they are called with golem::invoke_js(&quot;function&quot;, &quot;element&quot;). This element is a series of elements (most of the time scalar elements) that can be used to select the DOM node you need to interact with. It can be a full jQuery selector, an id or a class. Note that you can pass multiple elements, with invoke_js ... parameters 19.4.1 golem::invoke_js() showid &amp; hideid, showclass &amp; hideclass show and hide elements through their id or class. golem::invoke_js(&quot;showid&quot;, ns(&quot;plot&quot;)) showhref &amp; hidehref hide and show a link by trying to match the href content. golem::invoke_js(&quot;showhref&quot;, &quot;panel2&quot;) clickon click on the element. You have to use the full jQuery selector. show &amp; hide show and hide elements, using the full jQuery selector. See ?golem::activate_js for a full list of built-in functions. 19.5 Learn more about JavaScript Here is a list of external resources to learn more about JavaScript: 19.5.1 JavaScript basics Mozilla JavaScript w3schools JavaScript Free Code Camp JavaScript For Cats Learn JS 19.5.2 jQuery jQuery Learning Center w3schools jQuery 19.5.3 Intermediate / advanced JavaScript Eloquent JavaScript You Don’t Know JS Yet See this dev.to post for a quick introduction to the general concept of web socket↩ This can also be done by wrapping a JS libraries inside a package, which will later be used inside an application. See for example {glouton}, which is a wrapper around the js-cookie JavaScript library.↩ You can now work with JavaScript in a server with Node.JS, but this is out of scope of this book. See linked resources to learn more.↩ This click behavior can also be done through $(&quot;.shiny-plot-output&quot;).click(...). We chose to display the on(&quot;click&quot;) pattern as it can be generalized to all DOM events.↩ "]
]
